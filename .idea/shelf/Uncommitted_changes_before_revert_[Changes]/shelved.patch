Index: src/main/java/com/doth/selector/executor/query/BasicKindQueryExecutor.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.doth.selector.executor.query;\r\n\r\nimport com.doth.selector.coordinator.core.process.BasicExecuteCoordinator;\r\nimport com.doth.selector.coordinator.core.ExecuteCoordinatorService;\r\n\r\n/**\r\n * 抽象查询执行器基类 - 强制子类持有实体类型信息\r\n * @param <T> 目标实体类型\r\n */\r\npublic abstract class BasicKindQueryExecutor<T> {\r\n\r\n    protected ExecuteCoordinatorService coordinator;\r\n\r\n    // protected final Class<T> beanClass;\r\n    protected Class<T> beanClass;\r\n\r\n\r\n    // 强制子类必须传入实体类型\r\n    protected BasicKindQueryExecutor() { // 开闭原则, 新增参数coordinator不需要selector门面类修改, 由子类自己重写setCoordinator方法即可\r\n        setCoordinator(new BasicExecuteCoordinator()); // 默认使用基础协调器\r\n    }\r\n\r\n    public void setBeanClass(Class<T> beanClass) {\r\n        if (this.beanClass != null) { // 使用该判断\r\n            throw new IllegalStateException(\"beanClass 已被初始化，禁止重复设置\");\r\n        }\r\n        this.beanClass = beanClass;\r\n    }\r\n\r\n    protected void setCoordinator(ExecuteCoordinatorService coordinator) {\r\n        this.coordinator = coordinator;\r\n    }\r\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/com/doth/selector/executor/query/BasicKindQueryExecutor.java b/src/main/java/com/doth/selector/executor/query/BasicKindQueryExecutor.java
--- a/src/main/java/com/doth/selector/executor/query/BasicKindQueryExecutor.java	(revision 87e6f271238a38728638a807e186f42abc0ad1e0)
+++ b/src/main/java/com/doth/selector/executor/query/BasicKindQueryExecutor.java	(date 1748910074855)
@@ -14,6 +14,9 @@
     // protected final Class<T> beanClass;
     protected Class<T> beanClass;
 
+    protected Class<?> dtoClass;
+
+
 
     // 强制子类必须传入实体类型
     protected BasicKindQueryExecutor() { // 开闭原则, 新增参数coordinator不需要selector门面类修改, 由子类自己重写setCoordinator方法即可
@@ -27,6 +30,13 @@
         this.beanClass = beanClass;
     }
 
+    public void setDtoClass(Class<?> dtoClass) {
+        if (this.dtoClass != null) { // 使用该判断
+            throw new IllegalStateException("dtoClass 已被初始化，禁止重复设置");
+        }
+        this.dtoClass = dtoClass;
+    }
+
     protected void setCoordinator(ExecuteCoordinatorService coordinator) {
         this.coordinator = coordinator;
     }
Index: src/main/java/com/doth/selector/dto/DTOSelectFieldsListFactory.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.doth.selector.dto;\r\n\r\nimport java.util.*;\r\nimport java.util.concurrent.ConcurrentHashMap;\r\n\r\n/**\r\n * DTO 字段路径选择器工厂：\r\n * 存储每个 dtoId 对应的字段列表（select 字段）。\r\n * 供 SQL 生成器在生成 SELECT 子句时使用。\r\n */\r\npublic class DTOSelectFieldsListFactory {\r\n\r\n    /**\r\n     * 一级 key：原始实体类\r\n     * 二级 key：dtoId\r\n     * 值：字段路径集合（如 t0.id, t1.depName）\r\n     */\r\n    private static final Map<Class<?>, Map<String, List<String>>> SELECT_FIELD_REGISTRY = new ConcurrentHashMap<>();\r\n\r\n    /**\r\n     * 注册 DTO 的查询字段路径列表\r\n     *\r\n     * @param entityClass 原始实体类\r\n     * @param dtoId       DTO 构造方法标识\r\n     * @param selectList  该 DTO 的查询字段列表，必须是完整的字段路径，如 t0.id\r\n     */\r\n    public static void register(Class<?> entityClass, String dtoId, List<String> selectList) {\r\n        if (entityClass == null || dtoId == null || selectList == null) return;\r\n        SELECT_FIELD_REGISTRY\r\n            .computeIfAbsent(entityClass, k -> new ConcurrentHashMap<>())\r\n            .put(dtoId, Collections.unmodifiableList(new ArrayList<>(selectList))); // 防御性拷贝并保护不被修改\r\n    }\r\n\r\n    /**\r\n     * 获取 DTO 的字段路径列表\r\n     *\r\n     * @param entityClass 原始实体类\r\n     * @param dtoId       DTO 构造方法标识\r\n     * @return 查询字段路径列表；如果未找到则返回空列表\r\n     */\r\n    public static List<String> resolveSelectList(Class<?> entityClass, String dtoId) {\r\n        if (entityClass == null || dtoId == null) return Collections.emptyList();\r\n        return SELECT_FIELD_REGISTRY\r\n                .getOrDefault(entityClass, Collections.emptyMap())\r\n                .getOrDefault(dtoId, Collections.emptyList());\r\n    }\r\n\r\n    /**\r\n     * 判断是否存在该 DTO 的字段列表（用于校验）\r\n     *\r\n     * @param entityClass 实体类\r\n     * @param dtoId       DTO 标识\r\n     * @return 是否存在\r\n     */\r\n    public static boolean contains(Class<?> entityClass, String dtoId) {\r\n        return SELECT_FIELD_REGISTRY.containsKey(entityClass) &&\r\n               SELECT_FIELD_REGISTRY.get(entityClass).containsKey(dtoId);\r\n    }\r\n\r\n    /**\r\n     * 清除所有注册（一般用于测试）\r\n     */\r\n    public static void clearAll() {\r\n        SELECT_FIELD_REGISTRY.clear();\r\n    }\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/com/doth/selector/dto/DTOSelectFieldsListFactory.java b/src/main/java/com/doth/selector/dto/DTOSelectFieldsListFactory.java
--- a/src/main/java/com/doth/selector/dto/DTOSelectFieldsListFactory.java	(revision 87e6f271238a38728638a807e186f42abc0ad1e0)
+++ b/src/main/java/com/doth/selector/dto/DTOSelectFieldsListFactory.java	(date 1748886827584)
@@ -25,6 +25,7 @@
      * @param selectList  该 DTO 的查询字段列表，必须是完整的字段路径，如 t0.id
      */
     public static void register(Class<?> entityClass, String dtoId, List<String> selectList) {
+        System.out.println("触发了哦");
         if (entityClass == null || dtoId == null || selectList == null) return;
         SELECT_FIELD_REGISTRY
             .computeIfAbsent(entityClass, k -> new ConcurrentHashMap<>())
Index: src/main/java/com/doth/selector/coordinator/supports/sqlgenerator/tool/AutoQueryGenerator.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.doth.selector.coordinator.supports.sqlgenerator.tool;\r\n\r\nimport com.doth.selector.anno.Id;\r\nimport com.doth.selector.anno.Join;\r\nimport com.doth.selector.anno.OneToOne;\r\nimport com.doth.selector.anno.DTOConstructor;\r\nimport com.doth.selector.common.exception.NonPrimaryKeyException;\r\nimport com.doth.selector.common.testbean.join3.User;\r\nimport com.doth.selector.common.util.AnnoNamingConvertUtil;\r\nimport com.doth.selector.common.util.NamingConvertUtil;\r\nimport com.doth.selector.dto.DtoStackResolver;\r\nimport com.doth.selector.executor.supports.builder.ConditionBuilder;\r\n\r\nimport java.lang.reflect.Constructor;\r\nimport java.lang.reflect.Field;\r\nimport java.util.*;\r\n\r\npublic class AutoQueryGenerator {\r\n\r\n    private static final String MAIN_ALIAS = \"t0\";\r\n    public static final int MAX_JOIN_LENGTH = 5;\r\n\r\n    private final Class<?> mainEntity;\r\n    private final Set<String> dtoFieldSet;\r\n    private final Set<String> conditionPrefixes;\r\n    private final List<String> selectList = new ArrayList<>();\r\n    private final List<String> joinClauses = new ArrayList<>();\r\n    private final Set<Class<?>> processedEntities = new HashSet<>();\r\n    private int joinLevel = 1;\r\n\r\n    public static String generated(Class<?> mainEntity) {\r\n        return new AutoQueryGenerator(mainEntity, null).generate();\r\n    }\r\n\r\n    public static String generated(Class<?> mainEntity, ConditionBuilder<?> conditionBuilder) {\r\n        return new AutoQueryGenerator(mainEntity, conditionBuilder).generate();\r\n    }\r\n\r\n    /**\r\n     * 初始化, 三运表达式 适应旧代码\r\n     *  1.mainEntity 2.dtoFieldSet 3.conditionPrefixes\r\n     * @param mainEntity 主实体\r\n     * @param conditionBuilder cb\r\n     */\r\n    private AutoQueryGenerator(Class<?> mainEntity, ConditionBuilder<?> conditionBuilder) {\r\n        this.mainEntity = mainEntity;\r\n        String dtoId = DtoStackResolver.resolveDTOIdFromStack();\r\n        this.dtoFieldSet = dtoId != null\r\n                ? extractDtoFieldNames(mainEntity, dtoId)\r\n                : null;\r\n        this.conditionPrefixes = conditionBuilder != null\r\n                ? conditionBuilder.extractJoinTablePrefixes()\r\n                : Collections.emptySet();\r\n    }\r\n\r\n    /**\r\n     * 搭建sql脚手架 通过 parseEntity 补充搭建变量\r\n     * @return sql\r\n     */\r\n    private String generate() {\r\n        parseEntity(mainEntity, MAIN_ALIAS, new HashSet<>());\r\n        String select = \"select \" + String.join(\", \", selectList);\r\n        String from = \"from \" + getTableName(mainEntity) + \" \" + MAIN_ALIAS;\r\n        return select + \"\\n\" + from + \"\\n\" + String.join(\"\\n\", joinClauses);\r\n    }\r\n\r\n    /**\r\n     * 解析实体, 核心是 (1层级拦截; (2循环检测; (3[字段, join, dto模式] 分流处理\r\n     *  joinFields + if (processedEntities.contains(entity)) { ... return } 组合完成循环依赖路径清理\r\n     * @param entity 实体\r\n     * @param alias 别名\r\n     * @param joinFields 关联字段集合\r\n     */\r\n    private void parseEntity(Class<?> entity, String alias, Set<Field> joinFields) {\r\n        if (joinFields.size() > MAX_JOIN_LENGTH) {\r\n            throw new RuntimeException(\"关联层级过深，建议检查实体设计是否合理: \" + entity.getSimpleName());\r\n        }\r\n        /*\r\n            首先\r\n                第一次进来, 直接add, 开始遍历处理字段, 这里我们忽略dto模式的处理\r\n            然后\r\n                遍历中遇到了join, 此时的 processedEntities 包含的是 t0, t0!=t1, 继续 add(entity);\r\n                又遇到了join: t0, t1, 是否包含t2? t0!=t1, 继续 add(entity);\r\n            假设 t1 包含了 t0,\r\n                遇到 join, processedEntities 包含 t0, t0!=t1, 继续 add(entity);\r\n                又遇到了 join: t0, t1, 此时t1持有t0, t0==t0, 开始检测 >>> ok\r\n         */\r\n        if (processedEntities.contains(entity)) {\r\n            System.out.println(\"进来了..\");\r\n            boolean breakable = joinFields.stream().anyMatch(f -> f.isAnnotationPresent(OneToOne.class));\r\n            if (!breakable) {\r\n                throw new RuntimeException(\"检测到未标注 @OneToOne 的循环引用: \" + entity.getSimpleName());\r\n            }\r\n            return;\r\n        }\r\n        processedEntities.add(entity);\r\n\r\n        // 开始分流\r\n        for (Field field : entity.getDeclaredFields()) {\r\n            field.setAccessible(true);\r\n\r\n            if (field.isAnnotationPresent(Join.class)) { // 处理join\r\n                String candidateAlias = \"t\" + joinLevel;\r\n                if (dtoFieldSet != null && !conditionPrefixes.contains(candidateAlias)) {\r\n                    continue;\r\n                }\r\n                Set<Field> newJoinFields = new HashSet<>(joinFields);\r\n                newJoinFields.add(field);\r\n                handleJoin(field, alias, newJoinFields);\r\n            } else if (dtoFieldSet != null) {\r\n                handleField4Dto(field, alias);\r\n            } else { // 处理普通字段\r\n                handleField(field, alias);\r\n            }\r\n        }\r\n        processedEntities.remove(entity);\r\n    }\r\n\r\n    /**\r\n     * 最终将 join 字段 组装成 join 子句: [join t0.d_id = t1.id] 然后递归处理从表字段\r\n     *  获取 join 的外键 t0.d_id\r\n     *  获取从表的主键\r\n     * @param field 字段\r\n     * @param alias 别名 t0\r\n     * @param joinFields 后续可能优化\r\n     */\r\n    private void handleJoin(Field field, String alias, Set<Field> joinFields) {\r\n        Join join = field.getAnnotation(Join.class);\r\n        // Only include FK in select when not in DTO mode\r\n        // 非DTO模式下才自动查询外键\r\n        if (dtoFieldSet == null) {\r\n            selectList.add(alias + \".\" + join.fk());\r\n        }\r\n\r\n        Class<?> refEntity = field.getType();\r\n        String nextAlias = \"t\" + joinLevel++;\r\n        Field pk = getPKField(refEntity);\r\n\r\n        joinClauses.add(String.format(\r\n                \"join %s %s ON %s.%s = %s.%s\",\r\n                getTableName(refEntity), nextAlias,\r\n                alias, join.fk(),\r\n                nextAlias, pk.getName())\r\n        );\r\n\r\n        parseEntity(refEntity, nextAlias, joinFields);\r\n    }\r\n\r\n    /**\r\n     * 处理普通字段\r\n     * @param field 字段\r\n     * @param alias 别名 t0\r\n     */\r\n    private void handleField(Field field, String alias) {\r\n        // 不处理从表下的主键\r\n        if (!MAIN_ALIAS.equals(alias) && field.isAnnotationPresent(Id.class)) {\r\n            return;\r\n        }\r\n        String column = NamingConvertUtil.camel2SnakeCase(field.getName());\r\n        selectList.add(alias + \".\" + column);\r\n    }\r\n\r\n    private void handleField4Dto(Field field, String alias) {\r\n        // 不处理从表? 这里有问题, 为什么不处理从表? 还是说我没理解?\r\n        if (!MAIN_ALIAS.equals(alias)) {\r\n            return;\r\n        }\r\n        String column = NamingConvertUtil.camel2SnakeCase(field.getName());\r\n        if (dtoFieldSet.contains(column)) {\r\n            selectList.add(alias + \".\" + column);\r\n        }\r\n    }\r\n\r\n    private Field getPKField(Class<?> entityClass) {\r\n        for (Field f : entityClass.getDeclaredFields()) {\r\n            if (f.isAnnotationPresent(Id.class)) {\r\n                return f;\r\n            }\r\n        }\r\n        throw new NonPrimaryKeyException(entityClass.getSimpleName() + \" 未找到主键字段, 请使用@Id注解标记主键\");\r\n    }\r\n\r\n    private String getTableName(Class<?> entity) {\r\n        return AnnoNamingConvertUtil.camel2Snake(entity, entity.getSimpleName());\r\n    }\r\n\r\n    private static Set<String> extractDtoFieldNames(Class<?> entityClass, String dtoId) {\r\n        Set<String> result = new HashSet<>();\r\n        for (Constructor<?> ctor : entityClass.getDeclaredConstructors()) {\r\n            if (ctor.isAnnotationPresent(DTOConstructor.class)\r\n                    && ctor.getAnnotation(DTOConstructor.class).id().equals(dtoId)) {\r\n                for (var param : ctor.getParameters()) {\r\n                    result.add(param.getName());\r\n                }\r\n                break;\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n\r\n    public static void main(String[] args) {\r\n        long start = System.currentTimeMillis();\r\n        String sql = generated(User.class);\r\n        System.out.println(\"total = \" + (System.currentTimeMillis() - start));\r\n        System.out.println(\"sql =\\n \" + sql);\r\n    }\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/com/doth/selector/coordinator/supports/sqlgenerator/tool/AutoQueryGenerator.java b/src/main/java/com/doth/selector/coordinator/supports/sqlgenerator/tool/AutoQueryGenerator.java
--- a/src/main/java/com/doth/selector/coordinator/supports/sqlgenerator/tool/AutoQueryGenerator.java	(revision 87e6f271238a38728638a807e186f42abc0ad1e0)
+++ b/src/main/java/com/doth/selector/coordinator/supports/sqlgenerator/tool/AutoQueryGenerator.java	(date 1748920799835)
@@ -3,15 +3,14 @@
 import com.doth.selector.anno.Id;
 import com.doth.selector.anno.Join;
 import com.doth.selector.anno.OneToOne;
-import com.doth.selector.anno.DTOConstructor;
+import com.doth.selector.anno.DependOn;
 import com.doth.selector.common.exception.NonPrimaryKeyException;
-import com.doth.selector.common.testbean.join3.User;
+import com.doth.selector.common.testbean.join.BaseEmpInfo;
 import com.doth.selector.common.util.AnnoNamingConvertUtil;
 import com.doth.selector.common.util.NamingConvertUtil;
-import com.doth.selector.dto.DtoStackResolver;
+import com.doth.selector.dto.DTOSelectFieldsListFactory;
 import com.doth.selector.executor.supports.builder.ConditionBuilder;
 
-import java.lang.reflect.Constructor;
 import java.lang.reflect.Field;
 import java.util.*;
 
@@ -20,73 +19,98 @@
     private static final String MAIN_ALIAS = "t0";
     public static final int MAX_JOIN_LENGTH = 5;
 
-    private final Class<?> mainEntity;
-    private final Set<String> dtoFieldSet;
+    private final Class<?> originalEntity;
+    private final Set<String> dtoSelectPaths;  // 已包含别名前缀的完整路径，如 t0.id, t1.dep_name
     private final Set<String> conditionPrefixes;
     private final List<String> selectList = new ArrayList<>();
     private final List<String> joinClauses = new ArrayList<>();
     private final Set<Class<?>> processedEntities = new HashSet<>();
     private int joinLevel = 1;
 
-    public static String generated(Class<?> mainEntity) {
-        return new AutoQueryGenerator(mainEntity, null).generate();
+    public static String generated(Class<?> entityClass) {
+        return new AutoQueryGenerator(entityClass, null).generate();
     }
 
-    public static String generated(Class<?> mainEntity, ConditionBuilder<?> conditionBuilder) {
-        return new AutoQueryGenerator(mainEntity, conditionBuilder).generate();
+    public static String generated(Class<?> entityClass, ConditionBuilder<?> conditionBuilder) {
+        return new AutoQueryGenerator(entityClass, conditionBuilder).generate();
     }
 
     /**
-     * 初始化, 三运表达式 适应旧代码
-     *  1.mainEntity 2.dtoFieldSet 3.conditionPrefixes
-     * @param mainEntity 主实体
-     * @param conditionBuilder cb
+     * 构造时：
+     * - 如果传入的 entityClass 标记了 @DependOn，则视为 DTO 模式
+     *   * 从注解中获取原始实体类 class
+     *   * 从 DTO 类名解析出 dtoId（SimpleName 中 $ 之后的部分）
+     *   * 从工厂拿到带别名前缀的 select 字段路径列表，填充 dtoSelectPaths
+     * - 否则正常模式，dtoSelectPaths 设为 null
+     * - conditionPrefixes 一如既往由 ConditionBuilder 提供
      */
-    private AutoQueryGenerator(Class<?> mainEntity, ConditionBuilder<?> conditionBuilder) {
-        this.mainEntity = mainEntity;
-        String dtoId = DtoStackResolver.resolveDTOIdFromStack();
-        this.dtoFieldSet = dtoId != null
-                ? extractDtoFieldNames(mainEntity, dtoId)
-                : null;
+    private AutoQueryGenerator(Class<?> entityClass, ConditionBuilder<?> conditionBuilder) {
+        Set<String> usedFieldPaths = conditionBuilder.getUsedFieldPaths();
+        System.out.println("usedFieldPaths = " + usedFieldPaths);
+        if (entityClass.isAnnotationPresent(DependOn.class)) {
+            DependOn dep = entityClass.getAnnotation(DependOn.class);
+            try {
+                this.originalEntity = Class.forName(dep.clzPath());
+            } catch (ClassNotFoundException e) {
+                throw new RuntimeException("无法反射原始实体类: " + dep.clzPath(), e);
+            }
+            // 从 DTO 类名解析 dtoId: e.g., Employee$empSimpleDTO -> empSimpleDTO
+            String simpleName = entityClass.getSimpleName();
+            // 将首字母转小写
+            simpleName = simpleName.substring(0, 1).toLowerCase(Locale.ROOT) + simpleName.substring(1);
+            String dtoId = simpleName;
+            // 强制加载 DTO 类，使其能够在静态代码块中注册 select 列
+            try {
+                Class.forName(entityClass.getName());
+            } catch (ClassNotFoundException e) {
+                // throw new RuntimeException("DTO 类未找到: " + dtoClassName, e);
+            }
+            System.out.println("dtoId = " + dtoId);
+            // 从工厂取出完整的 select 列路径
+            List<String> paths = DTOSelectFieldsListFactory.resolveSelectList(originalEntity, dtoId);
+            if (paths.isEmpty()) {
+                throw new RuntimeException("未在 DTOSelectFieldsListFactory 中找到对应 DTO 的 select 列: "
+                        + originalEntity.getName() + "#" + dtoId);
+            }
+            this.dtoSelectPaths = new HashSet<>(paths);
+        } else {
+            this.originalEntity = entityClass;
+            this.dtoSelectPaths = null;
+        }
         this.conditionPrefixes = conditionBuilder != null
                 ? conditionBuilder.extractJoinTablePrefixes()
                 : Collections.emptySet();
     }
 
-    /**
-     * 搭建sql脚手架 通过 parseEntity 补充搭建变量
-     * @return sql
-     */
     private String generate() {
-        parseEntity(mainEntity, MAIN_ALIAS, new HashSet<>());
+        if (dtoSelectPaths != null) {
+            // 先填充 SELECT 列，已包含前缀
+            selectList.addAll(dtoSelectPaths);
+            // 再递归生成必须的 JOIN
+            parseEntity(originalEntity, MAIN_ALIAS, new HashSet<>());
+        } else {
+            // 非 DTO 模式：逐字段收集 select，并生成 join
+            parseEntity(originalEntity, MAIN_ALIAS, new HashSet<>());
+        }
         String select = "select " + String.join(", ", selectList);
-        String from = "from " + getTableName(mainEntity) + " " + MAIN_ALIAS;
+        String from = "from " + getTableName(originalEntity) + " " + MAIN_ALIAS;
         return select + "\n" + from + "\n" + String.join("\n", joinClauses);
     }
 
     /**
-     * 解析实体, 核心是 (1层级拦截; (2循环检测; (3[字段, join, dto模式] 分流处理
-     *  joinFields + if (processedEntities.contains(entity)) { ... return } 组合完成循环依赖路径清理
-     * @param entity 实体
-     * @param alias 别名
-     * @param joinFields 关联字段集合
+     * 解析实体：
+     * - 检测层级是否超过 MAX_JOIN_LENGTH
+     * - 检测循环引用（processedEntities）并依据 @OneToOne 决定是否继续
+     * - 遍历字段：
+     *   * 如果是 @Join：判断是否需要生成这个 JOIN（DTO 模式下，仅当 alias 存在于路径集合或 conditionPrefixes 才生成）
+     *     并在需要时调用 handleJoin
+     *   * 如果是非 @Join 且处于非 DTO 模式，则调用 handleField
      */
     private void parseEntity(Class<?> entity, String alias, Set<Field> joinFields) {
         if (joinFields.size() > MAX_JOIN_LENGTH) {
-            throw new RuntimeException("关联层级过深，建议检查实体设计是否合理: " + entity.getSimpleName());
+            throw new RuntimeException("关联层级过深，建议检查实体设计: " + entity.getSimpleName());
         }
-        /*
-            首先
-                第一次进来, 直接add, 开始遍历处理字段, 这里我们忽略dto模式的处理
-            然后
-                遍历中遇到了join, 此时的 processedEntities 包含的是 t0, t0!=t1, 继续 add(entity);
-                又遇到了join: t0, t1, 是否包含t2? t0!=t1, 继续 add(entity);
-            假设 t1 包含了 t0,
-                遇到 join, processedEntities 包含 t0, t0!=t1, 继续 add(entity);
-                又遇到了 join: t0, t1, 此时t1持有t0, t0==t0, 开始检测 >>> ok
-         */
         if (processedEntities.contains(entity)) {
-            System.out.println("进来了..");
             boolean breakable = joinFields.stream().anyMatch(f -> f.isAnnotationPresent(OneToOne.class));
             if (!breakable) {
                 throw new RuntimeException("检测到未标注 @OneToOne 的循环引用: " + entity.getSimpleName());
@@ -95,64 +119,66 @@
         }
         processedEntities.add(entity);
 
-        // 开始分流
         for (Field field : entity.getDeclaredFields()) {
             field.setAccessible(true);
-
-            if (field.isAnnotationPresent(Join.class)) { // 处理join
-                String candidateAlias = "t" + joinLevel;
-                if (dtoFieldSet != null && !conditionPrefixes.contains(candidateAlias)) {
-                    continue;
+            if (field.isAnnotationPresent(Join.class)) {
+                String nextAlias = "t" + joinLevel;
+                boolean needJoin = false;
+                if (dtoSelectPaths != null) {
+                    // 当路径集中有字段以 nextAlias." 开头，说明这个分支的字段在 SELECT 中，需要 JOIN
+                    String prefix = nextAlias + ".";
+                    for (String path : dtoSelectPaths) {
+                        if (path.startsWith(prefix)) {
+                            needJoin = true;
+                            break;
+                        }
+                    }
+                    // 或者条件中需要该 alias
+                    if (!needJoin && conditionPrefixes.contains(nextAlias)) {
+                        needJoin = true;
+                    }
+                } else {
+                    // 非 DTO 模式：总是生成所有 JOIN
+                    needJoin = true;
                 }
-                Set<Field> newJoinFields = new HashSet<>(joinFields);
-                newJoinFields.add(field);
-                handleJoin(field, alias, newJoinFields);
-            } else if (dtoFieldSet != null) {
-                handleField4Dto(field, alias);
-            } else { // 处理普通字段
+                if (needJoin) {
+                    Set<Field> newJoinFields = new HashSet<>(joinFields);
+                    newJoinFields.add(field);
+                    handleJoin(field, alias, newJoinFields);
+                }
+            } else if (dtoSelectPaths == null) {
+                // 非 DTO 模式下才添加普通字段
                 handleField(field, alias);
             }
+            // DTO 模式下，普通字段不在这里处理，因为已经在生成前填充了 selectList
         }
         processedEntities.remove(entity);
     }
 
     /**
-     * 最终将 join 字段 组装成 join 子句: [join t0.d_id = t1.id] 然后递归处理从表字段
-     *  获取 join 的外键 t0.d_id
-     *  获取从表的主键
-     * @param field 字段
-     * @param alias 别名 t0
-     * @param joinFields 后续可能优化
+     * 生成 JOIN 子句，并继续递归下游实体
+     * @param field 当前带 @Join 的字段
+     * @param alias 当前实体别名
+     * @param joinFields 已访问的 join 字段，用于深度和循环检测
      */
     private void handleJoin(Field field, String alias, Set<Field> joinFields) {
         Join join = field.getAnnotation(Join.class);
-        // Only include FK in select when not in DTO mode
-        // 非DTO模式下才自动查询外键
-        if (dtoFieldSet == null) {
-            selectList.add(alias + "." + join.fk());
-        }
-
         Class<?> refEntity = field.getType();
         String nextAlias = "t" + joinLevel++;
+        // 获取目标表的主键列
         Field pk = getPKField(refEntity);
-
         joinClauses.add(String.format(
                 "join %s %s ON %s.%s = %s.%s",
                 getTableName(refEntity), nextAlias,
                 alias, join.fk(),
-                nextAlias, pk.getName())
-        );
-
+                nextAlias, pk.getName()));
         parseEntity(refEntity, nextAlias, joinFields);
     }
 
     /**
-     * 处理普通字段
-     * @param field 字段
-     * @param alias 别名 t0
+     * 非 DTO 模式：处理普通字段，非主表主键，添加到 selectList
      */
     private void handleField(Field field, String alias) {
-        // 不处理从表下的主键
         if (!MAIN_ALIAS.equals(alias) && field.isAnnotationPresent(Id.class)) {
             return;
         }
@@ -160,48 +186,22 @@
         selectList.add(alias + "." + column);
     }
 
-    private void handleField4Dto(Field field, String alias) {
-        // 不处理从表? 这里有问题, 为什么不处理从表? 还是说我没理解?
-        if (!MAIN_ALIAS.equals(alias)) {
-            return;
-        }
-        String column = NamingConvertUtil.camel2SnakeCase(field.getName());
-        if (dtoFieldSet.contains(column)) {
-            selectList.add(alias + "." + column);
-        }
-    }
-
     private Field getPKField(Class<?> entityClass) {
         for (Field f : entityClass.getDeclaredFields()) {
             if (f.isAnnotationPresent(Id.class)) {
                 return f;
             }
         }
-        throw new NonPrimaryKeyException(entityClass.getSimpleName() + " 未找到主键字段, 请使用@Id注解标记主键");
+        throw new NonPrimaryKeyException(entityClass.getSimpleName() + " 未找到主键字段，请使用 @Id 注解标记主键");
     }
 
     private String getTableName(Class<?> entity) {
         return AnnoNamingConvertUtil.camel2Snake(entity, entity.getSimpleName());
     }
 
-    private static Set<String> extractDtoFieldNames(Class<?> entityClass, String dtoId) {
-        Set<String> result = new HashSet<>();
-        for (Constructor<?> ctor : entityClass.getDeclaredConstructors()) {
-            if (ctor.isAnnotationPresent(DTOConstructor.class)
-                    && ctor.getAnnotation(DTOConstructor.class).id().equals(dtoId)) {
-                for (var param : ctor.getParameters()) {
-                    result.add(param.getName());
-                }
-                break;
-            }
-        }
-        return result;
-    }
 
     public static void main(String[] args) {
-        long start = System.currentTimeMillis();
-        String sql = generated(User.class);
-        System.out.println("total = " + (System.currentTimeMillis() - start));
-        System.out.println("sql =\n " + sql);
+        String generated = generated(BaseEmpInfo.class);
+        System.out.println("generated = " + generated);
     }
 }
Index: src/main/java/com/doth/selector/coordinator/convertor/join/JoinBeanConvertor.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.doth.selector.coordinator.convertor.join;\r\n\r\nimport com.doth.selector.anno.Join;\r\nimport com.doth.selector.anno.UseDTO;\r\nimport com.doth.selector.common.convertor.ValueConverterFactory;\r\nimport com.doth.selector.coordinator.convertor.BeanConvertor;\r\nimport com.doth.selector.common.util.TypeResolver;\r\nimport com.doth.selector.dto.DTOFactory;\r\nimport com.doth.selector.dto.DtoStackResolver;\r\n\r\nimport java.lang.invoke.MethodHandle;\r\nimport java.lang.invoke.MethodHandles;\r\nimport java.lang.reflect.Field;\r\nimport java.lang.reflect.Method;\r\nimport java.sql.ResultSet;\r\nimport java.sql.ResultSetMetaData;\r\nimport java.sql.SQLException;\r\nimport java.util.HashMap;\r\nimport java.util.Map;\r\nimport java.util.concurrent.ConcurrentHashMap;\r\n\r\n/**\r\n * 联查结果转换器：将 ResultSet 映射为嵌套结构 JavaBean\r\n * 支持 @Join 注解、一对一嵌套、多级递归、缓存优化\r\n */\r\npublic class JoinBeanConvertor implements BeanConvertor {\r\n\r\n    /**\r\n     * 类结构元缓存：避免重复解析\r\n     */\r\n    private static final Map<Class<?>, MetaMap> JOIN_CACHE = new HashMap<>();\r\n\r\n    /**\r\n     * 字段Setter缓存，避免重复生成\r\n     */\r\n    private static final Map<Field, MethodHandle> SETTER_CACHE = new HashMap<>();\r\n\r\n    /**\r\n     * 核心入口：将 ResultSet 映射为嵌套JavaBean\r\n     */\r\n    @Override\r\n    public <T> T convert(ResultSet rs, Class<T> beanClass) throws Throwable {\r\n        ResultSetMetaData meta = rs.getMetaData();\r\n\r\n        MetaMap metaMap;\r\n        try {\r\n            metaMap = JOIN_CACHE.computeIfAbsent(beanClass, clz -> {\r\n                try {\r\n                    return analyzeClzStruct(clz, meta, \"\");\r\n                } catch (Exception e) {\r\n                    throw new RuntimeException(e);\r\n                }\r\n            });\r\n            return buildJoinBean(rs, beanClass, metaMap);\r\n        } catch (RuntimeException e) {\r\n            throw new SQLException(\"联表结构解析失败\", e);\r\n        } finally {\r\n            DtoStackResolver.clear();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * 解析类字段结构，支持嵌套结构\r\n     */\r\n    private MetaMap analyzeClzStruct(Class<?> clz, ResultSetMetaData meta, String prefix) throws Exception {\r\n        MetaMap metaMap = new MetaMap();\r\n\r\n        for (Field field : clz.getDeclaredFields()) {\r\n            field.setAccessible(true);\r\n\r\n            Join join = field.getAnnotation(Join.class);\r\n            if (join != null) {\r\n                String fkColumn = join.fk();\r\n                String refColumn = join.refFK();\r\n\r\n                if (columnExists(meta, fkColumn)) {\r\n                    Class<?> refClass = field.getType();\r\n                    String nestedPrefix = field.getName() + \"_\";\r\n                    MetaMap refMapping = analyzeClzStruct(refClass, meta, nestedPrefix);\r\n                    metaMap.addNestedMeta(field, refMapping, fkColumn, refColumn);\r\n                }\r\n            } else {\r\n                String columnName = prefix + field.getName();\r\n                if (columnExists(meta, columnName)) {\r\n                    metaMap.addFieldMeta(field, columnName);\r\n                }\r\n            }\r\n        }\r\n\r\n        return metaMap;\r\n    }\r\n\r\n    /**\r\n     * 字段是否存在于结果集\r\n     */\r\n    private boolean columnExists(ResultSetMetaData meta, String columnName) throws SQLException {\r\n        int columnCount = meta.getColumnCount();\r\n        for (int i = 1; i <= columnCount; i++) {\r\n            if (meta.getColumnLabel(i).equalsIgnoreCase(columnName)) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n\r\n    /**\r\n     * 构建嵌套对象（递归）\r\n     */\r\n    private <T> T buildJoinBean(ResultSet rs, Class<T> beanClass, MetaMap metaMap) throws Throwable {\r\n        // 1. 通过调用栈查找是否启用了 UseDTO 注解\r\n        String dtoId = DtoStackResolver.resolveDTOIdFromStack();\r\n\r\n        // 2. 尝试使用 DTOFactory 获取子类，如果没有，则退回使用原类型\r\n        Class<?> actualClass = DTOFactory.resolve(beanClass, dtoId);\r\n        T bean = (T) actualClass.getDeclaredConstructor().newInstance();\r\n        // System.out.println(\"actualClass = \" + actualClass);\r\n\r\n\r\n        for (Map.Entry<Field, String> entry : metaMap.getFieldMeta().entrySet()) {\r\n            Object val = rs.getObject(entry.getValue());\r\n            setFieldValue(bean, entry.getKey(), val);\r\n        }\r\n\r\n        for (Map.Entry<Field, MetaMap> entry : metaMap.getNestedMeta().entrySet()) {\r\n            Field field = entry.getKey();\r\n            MetaMap nestedMeta = entry.getValue();\r\n\r\n            String fkColumn = metaMap.getFkColumn(field);\r\n            String refColumn = metaMap.getRefColumn(field);\r\n            Object fkValue = rs.getObject(fkColumn);\r\n\r\n            Object refBean = buildJoinBean(rs, field.getType(), nestedMeta);\r\n            Field refField = getField(field.getType(), refColumn);\r\n            if (refField != null) {\r\n                setFieldValue(refBean, refField, fkValue);\r\n            }\r\n            setFieldValue(bean, field, refBean);\r\n        }\r\n\r\n        return bean;\r\n    }\r\n\r\n    /**\r\n     * 字段赋值：支持默认值容错\r\n     */\r\n    private void setFieldValue(Object target, Field field, Object value) {\r\n        MethodHandle setter = SETTER_CACHE.computeIfAbsent(field, f -> {\r\n            try {\r\n                return MethodHandles.lookup().unreflectSetter(f);\r\n            } catch (IllegalAccessException e) {\r\n                throw new RuntimeException(e);\r\n            }\r\n        });\r\n\r\n        try {\r\n            setter.invoke(target, value);\r\n        } catch (Throwable e1) {\r\n            try {\r\n                setter.invoke(target, ValueConverterFactory.convertIfPossible(field.getType(), value));\r\n            } catch (Throwable e2) {\r\n                try {\r\n                    setter.invoke(target, TypeResolver.getDefaultValue(field.getType()));\r\n                } catch (Throwable ignored) {\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * 获取字段\r\n     */\r\n    private Field getField(Class<?> clz, String name) {\r\n        for (Field field : clz.getDeclaredFields()) {\r\n            if (field.getName().equals(name)) {\r\n                field.setAccessible(true);\r\n                return field;\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/com/doth/selector/coordinator/convertor/join/JoinBeanConvertor.java b/src/main/java/com/doth/selector/coordinator/convertor/join/JoinBeanConvertor.java
--- a/src/main/java/com/doth/selector/coordinator/convertor/join/JoinBeanConvertor.java	(revision 87e6f271238a38728638a807e186f42abc0ad1e0)
+++ b/src/main/java/com/doth/selector/coordinator/convertor/join/JoinBeanConvertor.java	(date 1748922694878)
@@ -1,15 +1,16 @@
 package com.doth.selector.coordinator.convertor.join;
 
+import com.doth.selector.anno.DependOn;
 import com.doth.selector.anno.Join;
-import com.doth.selector.anno.UseDTO;
 import com.doth.selector.common.convertor.ValueConverterFactory;
+import com.doth.selector.common.testbean.join.Employee;
 import com.doth.selector.coordinator.convertor.BeanConvertor;
 import com.doth.selector.common.util.TypeResolver;
-import com.doth.selector.dto.DTOFactory;
-import com.doth.selector.dto.DtoStackResolver;
+// import com.doth.selector.dto.DtoStackResolver;
 
 import java.lang.invoke.MethodHandle;
 import java.lang.invoke.MethodHandles;
+import java.lang.reflect.Constructor;
 import java.lang.reflect.Field;
 import java.lang.reflect.Method;
 import java.sql.ResultSet;
@@ -19,43 +20,75 @@
 import java.util.Map;
 import java.util.concurrent.ConcurrentHashMap;
 
+
 /**
- * 联查结果转换器：将 ResultSet 映射为嵌套结构 JavaBean
- * 支持 @Join 注解、一对一嵌套、多级递归、缓存优化
+ * JoinBeanConvertor 已支持 @DependOn 注解：
+ * 1. 若 beanClass 标注了 @DependOn(clzPath="...")，则先反射出真正的实体类；
+ * 2. 按照原逻辑把 ResultSet 映射到该实体；
+ * 3. 构建完实体后，若存在 @DependOn，就寻找 beanClass 中形参为实体类型的构造方法，
+ *    并用刚才映射出的实体作为参数新建 DTO，最后返回 DTO 实例。
  */
 public class JoinBeanConvertor implements BeanConvertor {
 
-    /**
-     * 类结构元缓存：避免重复解析
-     */
+    /** 缓存：原始 beanClass 对应的映射元信息（最终用于 buildJoinBean） */
     private static final Map<Class<?>, MetaMap> JOIN_CACHE = new HashMap<>();
 
-    /**
-     * 字段Setter缓存，避免重复生成
-     */
+    /** 缓存：字段对应的 setter MethodHandle（与原逻辑一致） */
     private static final Map<Field, MethodHandle> SETTER_CACHE = new HashMap<>();
 
     /**
-     * 核心入口：将 ResultSet 映射为嵌套JavaBean
+     * 新增：DTO 构造器缓存，Key 为 DTO 类型，Value 为接收实体的单参构造器
      */
+    private static final Map<Class<?>, Constructor<?>> DTO_CTOR_CACHE = new HashMap<>();
+
     @Override
     public <T> T convert(ResultSet rs, Class<T> beanClass) throws Throwable {
-        ResultSetMetaData meta = rs.getMetaData();
-
-        MetaMap metaMap;
+        System.out.println("beanClass = " + beanClass);
         try {
-            metaMap = JOIN_CACHE.computeIfAbsent(beanClass, clz -> {
+            Class<?> effectiveClass = beanClass;
+            boolean isDto = false;
+
+            if (beanClass.isAnnotationPresent(DependOn.class)) {
+                DependOn depend = beanClass.getAnnotation(DependOn.class);
+                effectiveClass = Class.forName(depend.clzPath());
+                System.out.println("effectiveClass = " + effectiveClass);
+                isDto = true;
+            }
+
+            ResultSetMetaData meta = rs.getMetaData();
+            MetaMap metaMap = JOIN_CACHE.computeIfAbsent(effectiveClass, clz -> {
                 try {
                     return analyzeClzStruct(clz, meta, "");
                 } catch (Exception e) {
-                    throw new RuntimeException(e);
+                    throw new RuntimeException("实体结构分析失败: " + clz.getName(), e);
                 }
             });
-            return buildJoinBean(rs, beanClass, metaMap);
-        } catch (RuntimeException e) {
-            throw new SQLException("联表结构解析失败", e);
-        } finally {
-            DtoStackResolver.clear();
+
+            @SuppressWarnings("unchecked")
+            Object entityInstance = buildJoinBean(rs, effectiveClass, metaMap);
+
+            if (!isDto) {
+                @SuppressWarnings("unchecked")
+                T result = (T) entityInstance;
+                return result;
+            }
+            Employee emp = (Employee)entityInstance;
+            System.out.println("emp = " + emp);
+
+            // ====== 以下部分改为先查缓存，再反射 ======
+            Constructor<?> ctor = DTO_CTOR_CACHE.get(beanClass);
+            if (ctor == null) {
+                // 第一次才去 getConstructor，找不到会抛异常
+                ctor = beanClass.getConstructor(effectiveClass);
+                // 强制可访问，以防构造器不是 public
+                ctor.setAccessible(true);
+                DTO_CTOR_CACHE.put(beanClass, ctor);
+            }
+            @SuppressWarnings("unchecked")
+            T dtoInstance = (T) ctor.newInstance(entityInstance);
+            return dtoInstance;
+        } catch (RuntimeException e){
+            throw new RuntimeException("result >> 实体 转换失败!" + e);
         }
     }
 
@@ -108,12 +141,15 @@
      * 构建嵌套对象（递归）
      */
     private <T> T buildJoinBean(ResultSet rs, Class<T> beanClass, MetaMap metaMap) throws Throwable {
-        // 1. 通过调用栈查找是否启用了 UseDTO 注解
-        String dtoId = DtoStackResolver.resolveDTOIdFromStack();
+        // // 1. 通过调用栈查找是否启用了 UseDTO 注解
+        // String dtoId = DtoStackResolver.resolveDTOIdFromStack();
+        //
+        // // 2. 尝试使用 DTOFactory 获取子类，如果没有，则退回使用原类型
+        // Class<?> actualClass = DTOFactory.resolve(beanClass, dtoId);
+        // T bean = (T) actualClass.getDeclaredConstructor().newInstance();
 
-        // 2. 尝试使用 DTOFactory 获取子类，如果没有，则退回使用原类型
-        Class<?> actualClass = DTOFactory.resolve(beanClass, dtoId);
-        T bean = (T) actualClass.getDeclaredConstructor().newInstance();
+        T bean = beanClass.getDeclaredConstructor().newInstance(); // 初始化主表
+
         // System.out.println("actualClass = " + actualClass);
 
 
Index: src/main/java/com/doth/selector/core/Selector.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.doth.selector.core;\r\n\r\nimport com.doth.selector.core.factory.CreateExecutorFactory;\r\nimport com.doth.selector.core.factory.impl.DefaultCreateExecutorFactory;\r\nimport com.doth.selector.core.model.ExecutorType;\r\nimport com.doth.selector.executor.query.BasicKindQueryExecutor;\r\nimport com.doth.selector.executor.query.basic.impl.BuilderQueryExecutor;\r\nimport com.doth.selector.executor.query.basic.impl.DirectQueryExecutor;\r\nimport com.doth.selector.executor.query.basic.impl.RawQueryExecutor;\r\nimport com.doth.selector.executor.query.enhanced.impl.BuilderQueryExecutorPro;\r\nimport com.doth.selector.executor.query.enhanced.impl.DirectQueryExecutorPro;\r\nimport com.doth.selector.executor.query.enhanced.impl.RawQueryExecutorPro;\r\nimport com.doth.selector.executor.supports.lambda.LambdaFieldPathResolver;\r\nimport com.doth.selector.executor.supports.lambda.SFunction;\r\n\r\nimport java.lang.reflect.ParameterizedType;\r\nimport java.lang.reflect.Type;\r\nimport java.lang.reflect.WildcardType;\r\nimport java.util.HashMap;\r\nimport java.util.Map;\r\n\r\n/**\r\n * 实体查询门面类 - 提供所有查询方法使用入口, 整合多种查询策略的执行器, 简化调用复杂度, 提高代码可读性\r\n *\r\n * <p>设计目标：\r\n * <ol>\r\n *   <li>通过缓存机制复用执行器实例，减少对象创建开销</li>\r\n *   <li>通过泛型保证类型安全，避免强制转换错误</li>\r\n *   <li>隐藏底层实现细节，提供简洁的链式调用API</li>\r\n * </ol>\r\n */\r\npublic class Selector<T> {\r\n\r\n    protected Class<T> beanClass;\r\n\r\n    public Class<T> getBeanClass() {\r\n        return beanClass;\r\n    }\r\n\r\n    // 默认执行器工厂（可通过替换实现扩展）\r\n    private static CreateExecutorFactory createExecutorFactory = new DefaultCreateExecutorFactory();\r\n    // 统一缓存：Class -> <执行器枚举,执行器实例>\r\n    private static final Map<Class<?>, Map<ExecutorType, BasicKindQueryExecutor<?>>> cache = new HashMap<>();\r\n\r\n\r\n    // 将动态获取子类泛型更改成了遍历继承链获取泛型, 避免抽象dao的子实现类不指定泛型则报错的现象\r\n    public Selector() {\r\n        // 指向实际实例化的子类, 例: this.class = EmpDAOImpl 而非 selector 本类\r\n        // 用于解析逻辑从最底层的实现类开始，沿继承链向上查找，确保能定位到开发者定义的泛型参数。\r\n        this.beanClass = resolveBeanClass(this.getClass());\r\n    }\r\n\r\n    @SuppressWarnings(\"unchecked\")\r\n    private Class<T> resolveBeanClass(Class<?> clazz) {\r\n        \r\n        // 从子类开始, 递进查找继承体系, 直到本类\r\n        while (clazz != null && !clazz.equals(Selector.class)) { // 区间: 子类 -> ... <- self\r\n\r\n            Type superType = clazz.getGenericSuperclass();// 返回参数化类型, 例: Selector<Employee>\r\n\r\n            if (superType instanceof ParameterizedType) {\r\n                ParameterizedType pt = (ParameterizedType) superType;\r\n\r\n                // 确保处理的是当前类 的原始类是 本类 -> 防御\r\n                if (pt.getRawType() == Selector.class) {\r\n                    // 获取实际泛型参数\r\n                    Type typeArg = pt.getActualTypeArguments()[0];\r\n                    \r\n                    // 判断用于确保类型转换安全\r\n                    if (typeArg instanceof Class) {\r\n                        return (Class<T>) typeArg;\r\n                    } else if (typeArg instanceof ParameterizedType) { //\r\n                        // 处理嵌套泛型, 例: 如List<Employee> -> List.class\r\n                        return (Class<T>) ((ParameterizedType) typeArg).getRawType();\r\n                    } else if (typeArg instanceof WildcardType) {\r\n                        throw new IllegalArgumentException(\"泛型参数不能是通配符类型\");\r\n                    }\r\n                    return (Class<T>) typeArg;\r\n                }\r\n\r\n            }\r\n\r\n            clazz = clazz.getSuperclass(); // 递进继承链\r\n        }\r\n\r\n        throw new IllegalArgumentException(\"必须在继承链中指定泛型参数\");\r\n    }\r\n\r\n\r\n\r\n    // region 静态方法API\r\n    public static <T> BuilderQueryExecutor<T> bud(Class<T> beanClass) {\r\n        return getExecutor(beanClass, ExecutorType.BUILDER, BuilderQueryExecutor.class);\r\n    }\r\n\r\n    public static <T> BuilderQueryExecutorPro<T> bud$(Class<T> beanClass) {\r\n        return getExecutor(beanClass, ExecutorType.BUILDER_PRO, BuilderQueryExecutorPro.class);\r\n    }\r\n\r\n\r\n    public static <T> RawQueryExecutor<T> raw(Class<T> beanClass) {\r\n        return getExecutor(beanClass, ExecutorType.RAW, RawQueryExecutor.class);\r\n    }\r\n\r\n    public static <T> RawQueryExecutorPro<T> raw$(Class<T> beanClass) {\r\n        return getExecutor(beanClass, ExecutorType.RAW_PRO, RawQueryExecutorPro.class);\r\n    }\r\n\r\n\r\n    public static <T> DirectQueryExecutor<T> dct(Class<T> beanClass) {\r\n        return getExecutor(beanClass, ExecutorType.DIRECT, DirectQueryExecutor.class);\r\n    }\r\n\r\n    public static <T> DirectQueryExecutorPro<T> dct$(Class<T> beanClass) {\r\n        return getExecutor(beanClass, ExecutorType.DIRECT_PRO, DirectQueryExecutorPro.class);\r\n    }\r\n    // endregion\r\n\r\n\r\n\r\n    // region 实例方法API\r\n    public BuilderQueryExecutor<T> bud() {\r\n        return getExecutor(beanClass, ExecutorType.BUILDER, BuilderQueryExecutor.class);\r\n    }\r\n\r\n    public BuilderQueryExecutorPro<T> bud$() {\r\n        return getExecutor(beanClass, ExecutorType.BUILDER_PRO, BuilderQueryExecutorPro.class);\r\n    }\r\n\r\n\r\n\r\n    public RawQueryExecutor<T> raw() {\r\n        return getExecutor(beanClass, ExecutorType.RAW, RawQueryExecutor.class);\r\n    }\r\n\r\n    public RawQueryExecutorPro<T> raw$() {\r\n        return getExecutor(beanClass, ExecutorType.RAW_PRO, RawQueryExecutorPro.class);\r\n    }\r\n\r\n\r\n    public DirectQueryExecutor<T> dct() { // 单表时可以使用\r\n        return getExecutor(beanClass, ExecutorType.DIRECT, DirectQueryExecutor.class);\r\n    }\r\n\r\n    public DirectQueryExecutorPro<T> dct$() {\r\n        return getExecutor(beanClass, ExecutorType.DIRECT_PRO, DirectQueryExecutorPro.class);\r\n    }\r\n\r\n    // endregion\r\n\r\n\r\n\r\n    /**\r\n     * 工厂获取中介\r\n     *  1.通过目标实例获取对应的所有执行器map\r\n     *  2.在执行器map中 通过执行器枚举 获取或创建 对应的单个执行器\r\n     *\r\n     * @param beanClass 目标 Bean 类型 (DAO)\r\n     * @param type 执行器类型\r\n     * @param executorClass 执行器类型\r\n     * @return 执行器实例\r\n     * @param <E> 界限划定, 确保执行器类型正确\r\n     */\r\n    @SuppressWarnings(\"unchecked\")\r\n    private static <E extends BasicKindQueryExecutor<?>> E getExecutor(Class<?> beanClass, ExecutorType type, Class<E> executorClass) {\r\n        // 获取或初始化类缓存\r\n        Map<ExecutorType, BasicKindQueryExecutor<?>> classCache = cache.computeIfAbsent(beanClass, k\r\n                -> new HashMap<>()\r\n        ); // 一参键目标类, 一参没有二参创建\r\n\r\n        // 懒加载执行器\r\n        BasicKindQueryExecutor<?> executor = classCache.computeIfAbsent(type, t -> createExecutorFactory.createExecutor(beanClass, type));\r\n\r\n        // 类型安全检查\r\n        if (!executorClass.isInstance(executor)) { // 对等检查, 避免类型混乱\r\n            throw new IllegalStateException(\"执行器类型不匹配: \" + executor.getClass());\r\n        }\r\n        return (E) executor;\r\n    }\r\n\r\n\r\n    public String field(SFunction<T, ?> lambda) {\r\n        return LambdaFieldPathResolver.resolve(lambda, beanClass);\r\n    }\r\n\r\n\r\n\r\n\r\n    /**\r\n     * 替换工厂 todo: 暂无其他工厂可替换\r\n     * @param factory 工厂\r\n     */\r\n    @Deprecated\r\n    public static void setExecutorFactory(CreateExecutorFactory factory) {\r\n        createExecutorFactory = factory;\r\n    }\r\n\r\n\r\n\r\n    /**\r\n     * 清理缓存\r\n     */\r\n    public static void clearAllCache() {\r\n        cache.clear();\r\n    }\r\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/com/doth/selector/core/Selector.java b/src/main/java/com/doth/selector/core/Selector.java
--- a/src/main/java/com/doth/selector/core/Selector.java	(revision 87e6f271238a38728638a807e186f42abc0ad1e0)
+++ b/src/main/java/com/doth/selector/core/Selector.java	(date 1748920094431)
@@ -10,6 +10,7 @@
 import com.doth.selector.executor.query.enhanced.impl.BuilderQueryExecutorPro;
 import com.doth.selector.executor.query.enhanced.impl.DirectQueryExecutorPro;
 import com.doth.selector.executor.query.enhanced.impl.RawQueryExecutorPro;
+import com.doth.selector.executor.supports.builder.ConditionBuilder;
 import com.doth.selector.executor.supports.lambda.LambdaFieldPathResolver;
 import com.doth.selector.executor.supports.lambda.SFunction;
 
@@ -17,7 +18,9 @@
 import java.lang.reflect.Type;
 import java.lang.reflect.WildcardType;
 import java.util.HashMap;
+import java.util.List;
 import java.util.Map;
+import java.util.function.Consumer;
 
 /**
  * 实体查询门面类 - 提供所有查询方法使用入口, 整合多种查询策略的执行器, 简化调用复杂度, 提高代码可读性
@@ -127,6 +130,17 @@
         return getExecutor(beanClass, ExecutorType.BUILDER_PRO, BuilderQueryExecutorPro.class);
     }
 
+    @SuppressWarnings("unchecked")
+    public <D> List<D> queryDtoList(Class<D> dtoClass, Consumer<ConditionBuilder<T>> setup) {
+        // 1. 拿一个基于实体类型 T 的 BuilderQueryExecutorPro
+        BuilderQueryExecutorPro<T> executor = bud$();
+        // 2. 把 dtoClass 注入到执行器里，表示“最后要把结果映射成这个 DTO”
+        executor.setDtoClass(dtoClass);
+        // 3. 真正用实体类型 beanClass 构造 ConditionBuilder，并执行查询，把结果映射成 DTO
+        return (List<D>) executor.query2Lst(setup, true);
+    }
+
+
 
 
     public RawQueryExecutor<T> raw() {
Index: src/main/java/com/doth/selector/executor/query/enhanced/impl/BuilderQueryExecutorPro.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.doth.selector.executor.query.enhanced.impl;\r\n\r\nimport com.doth.selector.anno.Overload;\r\nimport com.doth.selector.coordinator.mapper.ResultSetMapper;\r\nimport com.doth.selector.executor.query.enhanced.JoinExecutor;\r\nimport com.doth.selector.executor.supports.builder.ConditionBuilder;\r\nimport com.doth.selector.executor.supports.lambda.SFunction;\r\n\r\nimport java.util.List;\r\nimport java.util.function.Consumer;\r\n\r\npublic class BuilderQueryExecutorPro<T> extends JoinExecutor<T>  {\r\n\r\n    // protected BuilderQueryExecutorPro(Class<T> beanClass) {\r\n    //     super(beanClass);\r\n    // }\r\n\r\n\r\n\r\n    @Overload\r\n    public List<T> query2Lst(Consumer<ConditionBuilder<T>> setup) {\r\n        ConditionBuilder<T> builder = new ConditionBuilder<>(beanClass);\r\n        setup.accept(builder);\r\n        return coordinator.queryByBuilder(beanClass, builder);\r\n    }\r\n\r\n    @Overload\r\n    @Deprecated\r\n    public List<T> query2Lst(String sql, Consumer<ConditionBuilder<T>> conditionSetup) {\r\n        ConditionBuilder<T> builder = new ConditionBuilder<T>();\r\n        conditionSetup.accept(builder);\r\n        return coordinator.queryByBuilderVzRaw(beanClass, sql, (ConditionBuilder<T>) builder);\r\n    }\r\n\r\n\r\n\r\n    @Overload\r\n    public T query2T(Consumer<ConditionBuilder<T>> setup) {\r\n        return ResultSetMapper.getSingleResult(query2Lst(setup));\r\n    }\r\n\r\n    @Overload\r\n    public T query2T(String sql, Consumer<ConditionBuilder<T>> conditionSetup) {\r\n        return ResultSetMapper.getSingleResult(query2Lst(sql, conditionSetup));\r\n    }\r\n\r\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/com/doth/selector/executor/query/enhanced/impl/BuilderQueryExecutorPro.java b/src/main/java/com/doth/selector/executor/query/enhanced/impl/BuilderQueryExecutorPro.java
--- a/src/main/java/com/doth/selector/executor/query/enhanced/impl/BuilderQueryExecutorPro.java	(revision 87e6f271238a38728638a807e186f42abc0ad1e0)
+++ b/src/main/java/com/doth/selector/executor/query/enhanced/impl/BuilderQueryExecutorPro.java	(date 1748918569127)
@@ -23,6 +23,13 @@
         setup.accept(builder);
         return coordinator.queryByBuilder(beanClass, builder);
     }
+    @Overload
+    public List<T> query2Lst(Consumer<ConditionBuilder<T>> setup, boolean dtoModel) {
+        ConditionBuilder<T> builder = new ConditionBuilder<>(beanClass); // beanClass = 实体类
+        setup.accept(builder);
+        return coordinator.queryByBuilder((Class<T>) dtoClass, builder); // 查询映射使用 dto
+    }
+
 
     @Overload
     @Deprecated
Index: src/main/java/com/doth/selector/coordinator/core/process/JoinExecuteCoordinator.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.doth.selector.coordinator.core.process;\r\n\r\nimport com.doth.selector.coordinator.core.ExecuteCoordinator;\r\nimport com.doth.selector.coordinator.mapper.ResultSetMapper;\r\nimport com.doth.selector.common.util.adapeter.EntityAdapter;\r\nimport com.doth.selector.executor.supports.builder.ConditionBuilder;\r\nimport com.doth.selector.coordinator.convertor.ConvertorType;\r\nimport com.doth.selector.coordinator.supports.sqlgenerator.facede.SelectGenerateFacade;\r\n\r\nimport java.util.*;\r\n\r\n/**\r\n * @author 贤\r\n * @version 1.0\r\n * @date 2025/4/5 21:11\r\n * @description 联查的执行协调者\r\n */\r\npublic class JoinExecuteCoordinator extends ExecuteCoordinator {\r\n\r\n    \r\n    // 更换策略, 表示该协调器统一采用多表映射策略\r\n    public JoinExecuteCoordinator() {\r\n        this.rsMapper = new ResultSetMapper(ConvertorType.JOIN_MAP);\r\n    }\r\n\r\n\r\n\r\n    @Override\r\n    public <T> List<T> queryByMap(Class<T> beanClass, LinkedHashMap<String, Object> cond) {\r\n        String sql = SelectGenerateFacade.generateJoin4map(beanClass, cond);\r\n\r\n        Object[] params = EntityAdapter.buildParams(cond);\r\n        return executeQuery(beanClass, sql, params);\r\n    }\r\n\r\n    @Override\r\n    public <T> List<T> queryByBuilder(Class<T> beanClass, ConditionBuilder<T> builder) {\r\n        builder.setEntityClz(beanClass); // 适配lambda\r\n\r\n        String sql = SelectGenerateFacade.generateJoin4builder(beanClass, builder);\r\n        Object[] params = builder.getParams();\r\n        return executeQuery(beanClass, sql, params);\r\n    }\r\n\r\n    @Override // todo: 有可能后续移除\r\n    public <T> List<T> queryByMapVzClause(Class<T> beanClass, LinkedHashMap<String, Object> cond, String strClause) {\r\n        String sql = SelectGenerateFacade.generateJoin4mapVzClause(beanClass, cond, strClause);\r\n        Object[] params =  EntityAdapter.buildParams(cond);\r\n        return executeQuery(beanClass, sql, params);\r\n    }\r\n\r\n    @Override\r\n    @Deprecated // todo: 有可能后续移除\r\n    public <T> List<T> queryByBuilderVzRaw(Class<T> beanClass, String sql, ConditionBuilder<T> builder) {\r\n        sql = SelectGenerateFacade.cvn4joinBuilderVzRaw(sql, builder);\r\n        // sqlgenerator = sqlgenerator + builder.getFullSql();\r\n        return executeQuery(beanClass, sql, builder.getParams());\r\n    }\r\n\r\n    @Override\r\n    public <T> List<T> queryByRaw(Class<T> beanClass, String sql, Object... params) {\r\n        String finalSql = SelectGenerateFacade.cvn4joinRaw(sql); //  自动生成别名 cvn: convert\r\n        // 自动展开所有List/Collection参数\r\n        List<Object> finalParams = new ArrayList<>();\r\n        for (Object param : params) {\r\n            if (param instanceof Collection) {\r\n                finalParams.addAll((Collection<?>) param);\r\n            } else {\r\n                finalParams.add(param);\r\n            }\r\n        }\r\n        return executeQuery(beanClass, finalSql, finalParams.toArray());\r\n    }\r\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/com/doth/selector/coordinator/core/process/JoinExecuteCoordinator.java b/src/main/java/com/doth/selector/coordinator/core/process/JoinExecuteCoordinator.java
--- a/src/main/java/com/doth/selector/coordinator/core/process/JoinExecuteCoordinator.java	(revision 87e6f271238a38728638a807e186f42abc0ad1e0)
+++ b/src/main/java/com/doth/selector/coordinator/core/process/JoinExecuteCoordinator.java	(date 1748922642119)
@@ -39,6 +39,7 @@
 
         String sql = SelectGenerateFacade.generateJoin4builder(beanClass, builder);
         Object[] params = builder.getParams();
+        System.out.println("beanClass = " + beanClass);
         return executeQuery(beanClass, sql, params);
     }
 
Index: src/test/java/com/doth/selector/newtest/EmployeeDAO.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.doth.selector.newtest;\r\n\r\nimport com.doth.selector.anno.CreateDaoImpl;\r\nimport com.doth.selector.anno.UseDTO;\r\nimport com.doth.selector.core.Selector;\r\nimport com.doth.selector.common.testbean.join.Employee;\r\nimport com.doth.selector.executor.supports.lambda.LambdaFieldPathResolver;\r\nimport com.doth.selector.executor.supports.lambda.SFunction;\r\nimport org.junit.Test;\r\n\r\nimport java.util.List;\r\n\r\n/**\r\n * @author 贤\r\n * @version 1.0\r\n * @date 2025/5/3 18:49\r\n * @description 测试员工查询接口\r\n *\r\n *  后续的 优化思路:\r\n *  1.自动 dto\r\n *      难点: 动态选择该方法返回 的 dto 类\r\n *\r\n *  2.懒加载忽略\r\n *      不加载不需要的类\r\n *      思路: 在sql生成的 时候拦截\r\n *      难点: 注解是在方法里加的, 怎么识别到?\r\n *      解决1: 在类中 标记懒加载策略注解, 方法里通过注解引用 (有些类似于JPA的做法)\r\n *          缺点: 实体类有了不该有的东西, 有点为了实现而实现了, 再加上 自己设置的构造方法缘由, 那么实体中的信息一定会太多太多的\r\n *          不过我有个方法\r\n *              首先我调用的方法 不就可以拿到 字节码, 然后判断获取注解吗\r\n *                  接着我就可以 走分支了, 然后把我的sql生成类 用工厂或者策略模式 进行 逻辑切换, 不就行了?\r\n *\r\n *  ================================================================================================\r\n *\r\n *  总结自动dto遇到的问题\r\n *  1.同参数构造方法无法控制\r\n *      解决: 考虑同样支持方法\r\n *  2.\r\n *\r\n */\r\n@CreateDaoImpl\r\npublic abstract class EmployeeDAO extends Selector<Employee> {\r\n\r\n    public static void main(String[] args) {\r\n        EmployeeDAO dao = new EmployeeDAOImpl();\r\n        List<Employee> impl = dao.impl();\r\n        // System.out.println(\"impl.get(0).getClass() = \" + impl.get(0).getClass());\r\n        System.out.println(\"impl = \" + impl);\r\n\r\n    }\r\n    @Test\r\n    public void testNew() {\r\n        List<Employee> impl = this.impl();\r\n        System.out.println(\"impl.get(0).getClass() = \" + impl.get(0).getClass());\r\n        System.out.println(\"impl = \" + impl);\r\n    }\r\n\r\n    @UseDTO(id = \"empSimple\")\r\n    public List<Employee> impl() {\r\n        return bud$().query2Lst(builder ->\r\n                builder.eq(e -> e.getDepartment().getName(), \"研发部\")\r\n        );\r\n    }\r\n\r\n    /**\r\n     * 根据员工姓名, 查询员工列表\r\n     * @param name 员工姓名\r\n     * @return 员工列表\r\n     */\r\n    public abstract List<Employee> queryByName(String name);\r\n\r\n\r\n    @Test\r\n    public void testQueryByName() {\r\n        //\r\n\r\n        long start = System.currentTimeMillis();\r\n        List<Employee> result = this.queryByName(\"张三\");\r\n        long cost = System.currentTimeMillis() - start;\r\n        System.out.println(\"queryByName 执行耗时: \" + cost + \"ms, 结果数量: \" + (result != null ? result.size() : 0));\r\n        System.out.println(\"result = \" + result);\r\n\r\n        System.out.println(\"result.getClass() = \" + result.get(0).getClass());\r\n\r\n    }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n    /**\r\n     * 根据部门名称, 查询员工列表\r\n     * @param name 部门姓名\r\n     * @return 员列表\r\n     */\r\n    public abstract List<Employee> queryByDepartmentName(String name);\r\n    \r\n    @Test\r\n    public void testQueryByDepartmentName() { // emp 包含 department,\r\n        long start = System.currentTimeMillis(); // 电脑有点卡\r\n        List<Employee> result = this.queryByDepartmentName(\"研发部\");\r\n        long cost = System.currentTimeMillis() - start;\r\n        System.out.println(\"queryByDepartmentName 执行耗时: \" + cost + \"ms, 结果数量: \" + (result != null ? result.size() : 0));\r\n        System.out.println(result);\r\n    }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n    /**\r\n     * 根据部门编号和员工姓名查询\r\n     * @param id 部门编号\r\n     * @param name 员工姓名\r\n     * @return 员工列表\r\n     */\r\n    public abstract List<Employee> queryByDepartmentIdVzName(Integer id, String name); // 完全不需要写东西, 一个方法名搞定\r\n    \r\n    @Test\r\n    public void testQueryByDepartmentIdVzName() { // Vz = with\r\n        long start = System.currentTimeMillis();\r\n        List<Employee> result = this.queryByDepartmentIdVzName(1, \"李四\"); // 框架用的是反射, 所以性能会块一点\r\n        long cost = System.currentTimeMillis() - start;\r\n        System.out.println(\"queryByDepartmentIdVzName 执行耗时: \" + cost + \"ms, 结果数量: \" + (result != null ? result.size() : 0));\r\n        System.out.println(result);\r\n    }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n    /**\r\n     * 根据部门编号, 和员工姓名模糊查询\r\n     * @param id 部门编号\r\n     * @param name 员工姓名\r\n     * @return 员工列表\r\n     */\r\n    public abstract List<Employee> queryByDepartmentIdAndNameLike(Integer id, String name); // 后续考虑使用注解解决方法名过长的问题\r\n    \r\n    @Test\r\n    public void testQueryByDepartmentIdAndNameLike() { //\r\n        long start = System.currentTimeMillis();\r\n        List<Employee> result = this.queryByDepartmentIdAndNameLike(1, \"张%\");\r\n        long cost = System.currentTimeMillis() - start;\r\n        System.out.println(\"queryByDepartmentIdAndNameLike 执行耗时: \" + cost + \"ms, 结果数量: \" + (result != null ? result.size() : 0));\r\n        System.out.println(result);\r\n    }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n    /**\r\n     * 根据部门名称和年龄大于某个值, 查询员工列表\r\n     * @param departmentName 部门名称\r\n     * @param age 年龄\r\n     * @return 员工列表\r\n     */\r\n    public abstract List<Employee> queryByDepartmentNameLikeAndAgeGt(String departmentName, Integer age);\r\n    @Test\r\n    public void testQueryByDepartmentNameLikeAndAgeGt() {\r\n        long start = System.currentTimeMillis();\r\n        List<Employee> result = this.queryByDepartmentNameLikeAndAgeGt(\"研发%\", 18); // 自动like gt = greater than\r\n        long cost = System.currentTimeMillis() - start;\r\n        System.out.println(\"queryByDepartmentNameLikeAndAgeGt 执行耗时: \" + cost + \"ms, 结果数量: \" + (result != null ? result.size() : 0));\r\n        System.out.println(result);\r\n    }\r\n\r\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/test/java/com/doth/selector/newtest/EmployeeDAO.java b/src/test/java/com/doth/selector/newtest/EmployeeDAO.java
--- a/src/test/java/com/doth/selector/newtest/EmployeeDAO.java	(revision 87e6f271238a38728638a807e186f42abc0ad1e0)
+++ b/src/test/java/com/doth/selector/newtest/EmployeeDAO.java	(date 1748920650481)
@@ -2,6 +2,8 @@
 
 import com.doth.selector.anno.CreateDaoImpl;
 import com.doth.selector.anno.UseDTO;
+// import com.doth.selector.common.testbean.join.BaseEmpInfo;
+import com.doth.selector.common.testbean.join.BaseEmpInfo;
 import com.doth.selector.core.Selector;
 import com.doth.selector.common.testbean.join.Employee;
 import com.doth.selector.executor.supports.lambda.LambdaFieldPathResolver;
@@ -43,9 +45,24 @@
 
     public static void main(String[] args) {
         EmployeeDAO dao = new EmployeeDAOImpl();
-        List<Employee> impl = dao.impl();
+        // List<Employee> impl = dao.impl();
+
+        List<BaseEmpInfo> implDto = dao.dtoImpl();
+
         // System.out.println("impl.get(0).getClass() = " + impl.get(0).getClass());
-        System.out.println("impl = " + impl);
+        // System.out.println("impl = " + impl);
+        implDto.forEach(e -> {
+            System.out.println("================================================================================");
+            System.out.println("e.getId() = " + e.getId());
+            System.out.println("e.getName() = " + e.getName());
+            System.out.println("e.getDepartmentId() = " + e.getDepartmentId());
+            System.out.println("e.getDepartmentName() = " + e.getDepartmentName());
+            System.out.println("e.getCompanyName() = " + e.getCompanyName());
+            System.out.println("================================================================================");
+        });
+
+        System.out.println("impl = " + implDto);
+
 
     }
     @Test
@@ -55,13 +72,30 @@
         System.out.println("impl = " + impl);
     }
 
-    @UseDTO(id = "empSimple")
+    // @UseDTO(id = "empSimple")
     public List<Employee> impl() {
         return bud$().query2Lst(builder ->
                 builder.eq(e -> e.getDepartment().getName(), "研发部")
         );
     }
 
+    @UseDTO(id = "baseEmpInfo")
+    public List<BaseEmpInfo> dtoImpl() {
+        /*
+            现在有一个情况:
+            1.当使用了 dto 模式的时候, 泛型不再共享, lambda 表达式也不再生效
+
+            思路: 因为自动dto的缘故, dto始终只可能存在一层, 所以最终eq的重载只可能存在一个
+         */
+        // return Selector.bud$(BaseEmpInfo.class).query2Lst(builder ->
+        //             builder.eq("t1.name", "研发部")
+        // );
+        return queryDtoList(BaseEmpInfo.class, builder -> {
+            // 这时 builder 的泛型是 ConditionBuilder<Employee>，所以 e.getDepartment().getName() 可以提示
+            builder.eq(e -> e.getDepartment().getName(), "研究部");
+        });
+    }
+
     /**
      * 根据员工姓名, 查询员工列表
      * @param name 员工姓名
Index: src/main/java/com/doth/selector/common/testbean/join/Employee.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.doth.selector.common.testbean.join;\r\n\r\nimport com.doth.selector.anno.*;\r\n\r\n/**\r\n * @project: test02\r\n * @package: com.doth.stupidrefframe.testbean\r\n * @author: doth\r\n * @creTime: 2025-03-27  11:35\r\n * @desc:\r\n * n+1\r\n *  select from emp...\r\n *      -> d_id\r\n *      select from dept where d_id = ?\r\n * @v: 1.0\r\n */\r\n@Entity\r\npublic class Employee {\r\n\r\n    @Id\r\n    private Integer id;\r\n\r\n    private String name;\r\n\r\n    private Integer age;\r\n\r\n    @Join(fk = \"d_id\", refFK = \"id\")\r\n    private Department department;\r\n\r\n\r\n\r\n\r\n    public Employee() {\r\n    }\r\n\r\n    /*\r\n        DTO新疑问: 当前的构造方法是这样的话, 我们就难以控制同样参数的构造的层级控制, 这后续可以通过 懒加载实现, 但使用的依然是实体, 似乎我的 DTO 生成方案有些难以解决这个问题\r\n\r\n        1.如果用户只要从表的 第一个 属性, 通常我们设计DTO的时候是 直接让它暴露 在外层\r\n            可是我现在的做法是 必须让\r\n        2.开发者创建的 DTO, 加入开发者 对其进行更新 最终一运行就把他们的 更改全部给弄没了, 开发者只能在 构造里 修改DTO (后期: [是否同步更改? Alt+Enter])\r\n            目前的做法, 确实有一些是不太妥当的, 因为最终目标是控制自动sql的生成, 让 sql 的生成参考 DTO, 也就是说, 完全完全不依赖构造方法的方法体,\r\n              方式一: 开发者仅仅需要 写一个构造方法签名就可以了, 优点是可以解决外部直接暴露外键的问题, 通过给参数定义一个 注解..\r\n              方式二: 但是要知道, 现在的手段是通过子类直接去访问 父类的构造方法, 仅仅需要super(...) 也就是说, 开发者可以在父类构造方法体中控制赋值操作\r\n                   1.外键字段\r\n\r\n               无论如何, 都解决不了,\r\n                1.最终返回的 字段的就算子类没有声明, 父类包含了, 那么这个字段就会为空, 也就是说,\r\n                这个DTO自动生成的方式, 实际上只是方便用于控制 [懒加载], 所以不应该叫做DTO, 而是叫做[懒加载模型LazyModel=LM]\r\n\r\n     */\r\n    public Employee(Integer id, String name, Integer age, Department department) {\r\n        this.id = id;\r\n        this.name = name;\r\n        this.age = age;\r\n        this.department = department;\r\n    }\r\n\r\n    // @DTOConstructor(id = \"empDeptVzId\")\r\n    public Employee(Integer id, String name, Integer age, Department department, Integer d_id) {\r\n        this.id = id;\r\n        this.name = name;\r\n        this.age = age;\r\n        this.department = department;\r\n        this.getDepartment().setId(d_id);\r\n    }\r\n\r\n    // @DTOConstructor(id = \"empWithDepId\")\r\n    public Employee(Integer id, String name, Integer age, Integer dId) {\r\n        this.id = id;\r\n        this.name = name;\r\n        this.age = age;\r\n        this.getDepartment().setId(dId);\r\n    }\r\n\r\n    /*\r\n        我想到一个方法:\r\n            被声明的 构造包含的字段 在生成的时候赋值为特殊默认值\r\n            这样就可以通过是否等于空, 获取查询列列表\r\n     */\r\n    // @DTOConstructor(id = \"empSimple\")\r\n    public Employee(Integer id, String name, Integer age) {}\r\n\r\n    @DTOConstructor(id = \"baseEmpInfo\")\r\n    public Employee(Integer id, String name,\r\n                    @JoinLevel(clz = Department.class) Integer department_id,\r\n                        String department_name,\r\n                    @Next(clz = Company.class) String company_name) {\r\n    }\r\n\r\n    \r\n    /*\r\n        构造方法构造查询列列表 方案:\r\n            难点:\r\n                1.动态层级\r\n                2.重名问题\r\n                3.冗余注解问题\r\n                    一个注解代表一个层级下的字段, 弊端是顺序难以控制, 好处是层级清晰, 方便阅读\r\n                    现在是 通过构造方法中的参数进行组装映射, 完全不关 DTO 的事, 现在的 DTO 完全就是 让返回的数据做一个命名\r\n            预想:\r\n                public Employee(Integer id, String name, Integer age,\r\n                    @JoinLevel(childTable = Department.class)\r\n                        Integer depId, String depName // -> dep前缀自动匹配 department.name, 如果撇皮失败则全前缀departmentName\r\n                    @JoinLevel(childTable = Company.class)\r\n                        @ColAlias(name = \"companyName\") String comName\r\n                ) {}\r\n\r\n\r\n\r\n\r\n            预想实体中声明的构造参数:\r\n                @DTOConstructor(id = \"baseEmpInfo\")\r\n                public Employee(\r\n                        @MainLevel // 可以省略\r\n                            Integer id, String name, Integer age,\r\n\r\n                            @JoinLevel(clz = Department.class) // -> 对应 t1\r\n                                Integer department_depId, String dep_depName, // -> 对应 this.department.name/id, 或者只输入 dep 自动对应 department; department_代表处于哪一个实体下, 后面才是字段名称\r\n                            @JoinLevel(childTable = Company.class)\r\n                                String com_name\r\n                ) {}\r\n\r\n            预想对应生成的DTO类:\r\n                @DependOn(clzPath = \"com.doth.selector.common.testbean.join.Employee employee\")\r\n                public class Employee$baseEmpInfoDTO >> 原来的DTO类命名\r\n                public class BaseEmpInfo >> 更改后\r\n                {\r\n                    List<String> selectList = new ArrayList<>();\r\n\r\n                    private com.doth.selector.common.testbean.join.Employee employee\r\n\r\n                    public BaseEmpInfo() {}\r\n                    public BaseEmpInfo(com.doth.selector.common.testbean.join.Employee employee) {\r\n                        this.id = employee.getId();\r\n                        this.name = employee.getName();\r\n                        this.age = employee.getAge();\r\n                        this.depId = employee.getDepartment().getDepId();\r\n                        this.depName = employee.getDepartment().getDepName();\r\n                        this.comName = employee.getDepartment().getCompany().getName();\r\n                    }\r\n                    // 主表信息\r\n                    private Integer id,\r\n                    private String name,\r\n                    private Integer age;\r\n\r\n                    // department 的信息\r\n                    private Integer depId;\r\n                    private Integer depName;\r\n\r\n                    // company 的信息\r\n                    // private String name; >> 错误! 当生成时发现字段名重复时, 替换为从表的 simpleName + fieldName\r\n                    private String comName; >> 正确! 默认使用从表的 simpleName 的 substring(0, 3) 作为最终字段名, 或者使用 @PfxAlias(name = \"company\") -> Pfx = Prefix, 最终: companyName, 反正最终字段名一定包含name, 只能自定义前缀, 算是该框架的规则\r\n\r\n\r\n\r\n                    static {\r\n                        DTOFactory.register(com.doth.selector.common.testbean.join.Employee.class, \"baseEmpInfo\", BaseEmpInfo.class 记得同类名.class);\r\n                        // 最后再将实际字段注册进一个 新的 [查询列列表] 工厂中, 你可以参考 DTOFactory 的做法进行创建\r\n                        selectList.add(\"t0.id\"); // 按构造顺序一一赋值, tN 的生成规则可以参考 ColumnPathResolver\r\n                        selectList.add(\"t0.name\");\r\n                        selectList.add(\"t0.age\");\r\n                        selectList.add(\"t1.depId\");\r\n                        selectList.add(\"t1.depName\");\r\n                        selectList.add(\"t2.name\"); // !!这里不是 t2.comName!! 字段写 comName 是为了防止重名\r\n                        DTOSelectFieldsListFactory.register(\"baseEmpInfo\", selectList);\r\n                        !![这样的话, AutoQueryGenerator 中的 extractDtoFieldNames 方法需要修改, 返回的是查询列列表, 返回前做一层循环依赖判断]!!\r\n                    }\r\n                    // getter, setter, equal, toString... 我来写\r\n                }\r\n\r\n    实体信息:\r\n                @Entity\r\n                public class Employee {\r\n\r\n                    @Id\r\n                    private Integer id;\r\n\r\n                    private String name;\r\n\r\n                    private Integer age;\r\n\r\n                    @Join(fk = \"d_id\", refFK = \"depId\")\r\n                    private Department department;\r\n                    ...\r\n                }\r\n                @Entity\r\n                public class Department {\r\n\r\n                    @Id\r\n                    private Integer depId;\r\n\r\n                    private String depName; // 框架还内置了检查, 强制要求实体类的字段都必须使用 包装类\r\n\r\n                    @Join(fk = \"com_id\", refFK = \"id\")\r\n                    private Company company;\r\n                    ...\r\n                }\r\n                @Entity\r\n                public class Company {\r\n\r\n                    @Id\r\n                    private Integer id;\r\n\r\n                    private String name;\r\n                    ...\r\n                }\r\n\r\n     */\r\n\r\n    public static void main(String[] args) {\r\n\r\n    }\r\n\r\n    /**\r\n     * 获取\r\n     * @return id\r\n     */\r\n    public Integer getId() {\r\n        return id;\r\n    }\r\n\r\n    /**\r\n     * 设置\r\n     * @param id\r\n     */\r\n    public void setId(Integer id) {\r\n        this.id = id;\r\n    }\r\n\r\n    /**\r\n     * 获取\r\n     * @return name\r\n     */\r\n    public String getName() {\r\n        return name;\r\n    }\r\n\r\n    /**\r\n     * 设置\r\n     * @param name\r\n     */\r\n    public void setName(String name) {\r\n        this.name = name;\r\n    }\r\n\r\n    /**\r\n     * 获取\r\n     * @return age\r\n     */\r\n    public Integer getAge() {\r\n        return age;\r\n    }\r\n\r\n    /**\r\n     * 设置\r\n     * @param age\r\n     */\r\n    public void setAge(Integer age) {\r\n        this.age = age;\r\n    }\r\n\r\n    /**\r\n     * 获取\r\n     * @return department\r\n     */\r\n    public Department getDepartment() {\r\n        return department;\r\n    }\r\n\r\n    /**\r\n     * 设置\r\n     * @param department\r\n     */\r\n    public void setDepartment(Department department) {\r\n        this.department = department;\r\n    }\r\n\r\n    public String toString() {\r\n        return \"Employee{id = \" + id + \", name = \" + name + \", age = \" + age + \", department = \" + department + \"}\";\r\n    }\r\n\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/com/doth/selector/common/testbean/join/Employee.java b/src/main/java/com/doth/selector/common/testbean/join/Employee.java
--- a/src/main/java/com/doth/selector/common/testbean/join/Employee.java	(revision 87e6f271238a38728638a807e186f42abc0ad1e0)
+++ b/src/main/java/com/doth/selector/common/testbean/join/Employee.java	(date 1748862663501)
@@ -82,13 +82,16 @@
     public Employee(Integer id, String name, Integer age) {}
 
     @DTOConstructor(id = "baseEmpInfo")
-    public Employee(Integer id, String name,
-                    @JoinLevel(clz = Department.class) Integer department_id,
-                        String department_name,
-                    @Next(clz = Company.class) String company_name) {
-    }
+    public Employee(
+                @MainLevel
+                    Integer id, String name,
+                @JoinLevel(clz = Department.class)
+                    Integer department_id, String department_name,
+                    @Next(clz = Company.class)
+                        String company_name
+    ) {}
 
-    
+
     /*
         构造方法构造查询列列表 方案:
             难点:
Index: src/test/java/com/doth/selector/EmployeeDAODctTest.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.doth.selector;// EmployeeDAODctTest.java 测试类\r\nimport com.doth.selector.common.testbean.join.Department;\r\nimport com.doth.selector.common.testbean.join.Employee;\r\nimport org.junit.Before;\r\nimport org.junit.Test;\r\n\r\nimport java.util.List;\r\n\r\npublic class EmployeeDAODctTest {\r\n    \r\n    private EmployeeDAO dao;\r\n    //\r\n    @Before\r\n    public void setUp() {\r\n        // dao = new EmployeeDAOImpl(); // 模拟service层注入\r\n    }\r\n\r\n    @Test\r\n    public void testQueryAll() {\r\n        long start = System.currentTimeMillis();\r\n        // 总共20条\r\n        List<Employee> employees = dao.dct$().query2Lst();\r\n\r\n        long end = System.currentTimeMillis();\r\n\r\n        System.out.println(\"queryAll result: \" + employees);\r\n        System.out.println(\"总耗时\" + (end - start));\r\n    }\r\n\r\n\r\n\r\n\r\n\r\n\r\n    @Test\r\n    public void testQueryById1() {\r\n        long start = System.currentTimeMillis();\r\n        List<Employee> result = dao.queryById1();\r\n        long end = System.currentTimeMillis();\r\n\r\n        System.out.println(\"queryById1 result: \" + result);\r\n        System.out.println(\"总耗时\" + (end - start));\r\n    }\r\n\r\n\r\n\r\n\r\n\r\n\r\n    @Test\r\n    public void testQueryById2() {\r\n        long start = System.currentTimeMillis();\r\n        List<Employee> result = dao.queryById2();\r\n        long end = System.currentTimeMillis();\r\n\r\n        System.out.println(\"queryById2 result: \" + result);\r\n        System.out.println(\"总耗时\" + (end - start));\r\n    }\r\n\r\n\r\n\r\n\r\n\r\n\r\n    @Test\r\n    public void testQueryByNameAndDepartmentIds3() {\r\n        long start = System.currentTimeMillis();\r\n        List<Employee> result = dao.queryByNameAndDepartmentIds3();\r\n        long end = System.currentTimeMillis();\r\n\r\n        System.out.println(\"queryByNameAndDepartmentIds3 result: \" + result);\r\n        System.out.println(\"总耗时\" + (end - start));\r\n    }\r\n\r\n\r\n\r\n\r\n\r\n\r\n    @Test\r\n    public void testQueryByNameAndDepartmentId1() {\r\n        long start = System.currentTimeMillis();\r\n        List<Employee> result = dao.queryByNameAndDepartmentId1();\r\n        long end = System.currentTimeMillis();\r\n\r\n        System.out.println(\"queryByNameAndDepartmentId1 result: \" + result);\r\n        System.out.println(\"总耗时\" + (end - start));\r\n    }\r\n\r\n\r\n\r\n\r\n\r\n\r\n    @Test\r\n    public void testQueryByNameAndDepartmentId2() {\r\n        // 模拟controller自动解析json结构 (实际开发不会这样写)\r\n        Employee param = new Employee();\r\n        param.setName(\"张三\");\r\n        Department department = new Department();\r\n        department.setId(1);\r\n        param.setDepartment(department);\r\n\r\n        long start = System.currentTimeMillis();\r\n        List<Employee> result = dao.queryByNameAndDepartmentId2(param);\r\n        long end = System.currentTimeMillis();\r\n\r\n        System.out.println(\"queryByNameAndDepartmentId2 result: \" + result);\r\n        System.out.println(\"总耗时\" + (end - start));\r\n    }\r\n\r\n\r\n\r\n\r\n\r\n\r\n    @Test\r\n    public void testQueryByNameAndDepartmentIds5() {\r\n        List<Employee> result = dao.queryByNameAndDepartmentIds5();\r\n        System.out.println(\"queryByNameAndDepartmentIds5 result: \" + result);\r\n    }\r\n\r\n\r\n\r\n\r\n\r\n\r\n    @Test\r\n    public void testQueryByNameAndDepartmentIds6() {\r\n        List<Employee> result = dao.queryByNameAndDepartmentIds6();\r\n        System.out.println(\"queryByNameAndDepartmentIds6 result: \" + result);\r\n    }\r\n\r\n\r\n\r\n\r\n\r\n\r\n    @Test\r\n    public void testQueryByNameAndDepartmentIds7() {\r\n        List<Employee> result = dao.queryByNameAndDepartmentIds7();\r\n        System.out.println(\"queryByNameAndDepartmentIds7 result: \" + result);\r\n    } // 支持游标分页\r\n\r\n\r\n\r\n\r\n\r\n\r\n    @Test\r\n    public void testQueryByNameAndDepartmentIds9() {\r\n        List<Employee> result = dao.queryByNameAndDepartmentIds9();\r\n        System.out.println(\"queryByNameAndDepartmentIds9 result: \" + result);\r\n    }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n    @Test\r\n    public void testQueryByDepartmentName() {\r\n        long start = System.currentTimeMillis();\r\n        List<Employee> result = dao.queryByDepartmentName(\"研发部\");\r\n        long end = System.currentTimeMillis();\r\n\r\n        System.out.println(\"queryByDepartmentName result: \" + result);\r\n        System.out.println(\"总耗时\" + (end - start));\r\n    }\r\n\r\n\r\n\r\n\r\n    @Test\r\n    public void testQueryByName() {\r\n        long start = System.currentTimeMillis();\r\n        List<Employee> result = dao.queryByName(\"李四\");\r\n        long end = System.currentTimeMillis();\r\n\r\n        System.out.println(\"queryByName result: \" + result);\r\n        System.out.println(\"总耗时\" + (end - start));\r\n    }\r\n\r\n    @Test\r\n    public void testQueryByDepartmentIdVzName() {\r\n        List<Employee> employees = dao.queryByDepartmentIdGtVzNameLike(1, \"张三%\");\r\n        System.out.println(\"employees = \" + employees);\r\n    }\r\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/test/java/com/doth/selector/EmployeeDAODctTest.java b/src/test/java/com/doth/selector/EmployeeDAODctTest.java
--- a/src/test/java/com/doth/selector/EmployeeDAODctTest.java	(revision 87e6f271238a38728638a807e186f42abc0ad1e0)
+++ b/src/test/java/com/doth/selector/EmployeeDAODctTest.java	(date 1748882243667)
@@ -9,10 +9,25 @@
 public class EmployeeDAODctTest {
     
     private EmployeeDAO dao;
+
+    public static void main(String[] args) {
+        long start = System.currentTimeMillis();
+        // 总共20条
+        EmployeeDAO dao = new EmployeeDAOImpl() ;
+
+        List<Employee> employees = dao.dct$().query2Lst();
+
+        long end = System.currentTimeMillis();
+
+        System.out.println("queryAll result: " + employees);
+        System.out.println("总耗时" + (end - start));
+    }
     //
     @Before
     public void setUp() {
         // dao = new EmployeeDAOImpl(); // 模拟service层注入
+
+
     }
 
     @Test
Index: src/main/java/com/doth/selector/anno/processor/DTOConstructorProcessor.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.doth.selector.anno.processor;\r\n\r\nimport com.doth.selector.anno.*;  // Import the custom annotations\r\nimport com.google.auto.service.AutoService;\r\n\r\nimport javax.annotation.processing.*;\r\nimport javax.lang.model.element.*;\r\nimport javax.lang.model.type.*;\r\nimport javax.lang.model.util.Elements;\r\nimport javax.lang.model.SourceVersion;\r\nimport javax.lang.model.util.Types;\r\nimport javax.tools.Diagnostic;\r\nimport javax.tools.JavaFileObject;\r\nimport java.util.*;\r\nimport java.io.Writer;\r\nimport java.io.IOException;\r\n\r\n@AutoService(Processor.class)\r\n@SupportedAnnotationTypes(\"com.doth.selector.anno.DTOConstructor\")\r\npublic class DTOConstructorProcessor extends AbstractProcessor {\r\n\r\n\r\n\r\n    private Filer filer;\r\n    private Messager messager;\r\n    private Types typeUtils;\r\n    private Elements elementUtils;\r\n\r\n    @Override\r\n    public SourceVersion getSupportedSourceVersion() {\r\n        return SourceVersion.latestSupported();\r\n    }\r\n\r\n    // 初始化注解处理器上下文环境\r\n    @Override\r\n    public synchronized void init(ProcessingEnvironment env) {\r\n        super.init(env);\r\n        this.filer = env.getFiler();\r\n        this.messager = env.getMessager();\r\n        this.typeUtils = env.getTypeUtils();\r\n        this.elementUtils = env.getElementUtils();\r\n    }\r\n\r\n    @Override\r\n    public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv) {\r\n        // Find all constructors annotated with @DTOConstructor\r\n        for (Element elem : roundEnv.getElementsAnnotatedWith(DTOConstructor.class)) {\r\n            if (!(elem instanceof ExecutableElement)) {\r\n                continue;\r\n            }\r\n            ExecutableElement constructorElement = (ExecutableElement) elem;\r\n            TypeElement entityClass = (TypeElement) constructorElement.getEnclosingElement();\r\n            DTOConstructor dtoAnnotation = constructorElement.getAnnotation(DTOConstructor.class);\r\n            String dtoId = dtoAnnotation.id();\r\n            generateDtoClass(entityClass, constructorElement, dtoId);\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Generates the DTO class source file for the given entity and constructor.\r\n     */\r\n    private void generateDtoClass(TypeElement entityClass, ExecutableElement constructorElement, String dtoId) {\r\n        // Determine package name of entity\r\n        Elements elementUtils = processingEnv.getElementUtils();\r\n        String entityQualifiedName = elementUtils.getBinaryName(entityClass).toString();\r\n        String packageName = \"\";\r\n        int lastDot = entityQualifiedName.lastIndexOf('.');\r\n        if (lastDot > 0) {\r\n            packageName = entityQualifiedName.substring(0, lastDot);\r\n        }\r\n        // Determine DTO class name (capitalize dtoId, handle underscores if any)\r\n        String dtoClassName = toCamelCase(dtoId, true);  // true for capitalize first letter\r\n        // Prepare content builder for class\r\n        StringBuilder classContent = new StringBuilder();\r\n        if (!packageName.isEmpty()) {\r\n            classContent.append(\"package \").append(packageName).append(\";\\n\\n\");\r\n        }\r\n        // Import statements for annotations and any needed classes\r\n        classContent.append(\"import java.util.ArrayList;\\n\");\r\n        classContent.append(\"import java.util.List;\\n\");\r\n        // Import the annotations (if not in same package)\r\n        classContent.append(\"import com.doth.selector.anno.DependOn;\\n\");\r\n        classContent.append(\"import com.doth.selector.anno.DTOConstructor;\\n\");  // in case needed for clarity, though not used inside class\r\n        // Import entity class if not same package\r\n        String entitySimpleName = entityClass.getSimpleName().toString();\r\n        if (!packageName.isEmpty() && !entityQualifiedName.equals(packageName + \".\" + entitySimpleName)) {\r\n            // If the entity class is in a different package (which would be unusual if names differ),\r\n            // but typically entityQualifiedName = packageName + \".\" + entitySimpleName.\r\n            // We'll ensure import is correct:\r\n            classContent.append(\"import \").append(entityQualifiedName).append(\";\\n\");\r\n        }\r\n        // Import DTOFactory and DTOSelectFieldsListFactory (assuming they are in accessible packages)\r\n        classContent.append(\"import com.doth.selector.dto.DTOFactory;\\n\");\r\n        classContent.append(\"import com.doth.selector.dto.DTOSelectFieldsListFactory;\\n\\n\");  // Adjust package as appropriate\r\n\r\n        // Class definition with @DependOn\r\n        classContent.append(\"@DependOn(clzPath=\\\"\").append(entityQualifiedName).append(\"\\\")\\n\");\r\n        classContent.append(\"public class \").append(dtoClassName).append(\" {\\n\\n\");\r\n\r\n        // Fields: one for each constructor parameter\r\n        List<? extends VariableElement> params = constructorElement.getParameters();\r\n        // Determine naming for each field\r\n        Set<String> mainFieldNames = new HashSet<>();       // names of main entity fields\r\n        List<ParamInfo> joinParamInfos = new ArrayList<>(); // info for join parameters\r\n        for (VariableElement param : params) {\r\n            String paramName = param.getSimpleName().toString();\r\n            if (!paramName.contains(\"_\")) {\r\n                mainFieldNames.add(paramName);\r\n            } else {\r\n                // Collect join param info (prefix and base name)\r\n                String prefix = paramName.substring(0, paramName.indexOf('_'));\r\n                String baseName = paramName.substring(paramName.indexOf('_') + 1);\r\n                // Check for @PfxAlias on this parameter\r\n                PfxAlias aliasAnn = param.getAnnotation(PfxAlias.class);\r\n                String aliasPrefix = (aliasAnn != null ? aliasAnn.name() : null);\r\n                joinParamInfos.add(new ParamInfo(prefix, baseName, aliasPrefix));\r\n            }\r\n        }\r\n        // Compute frequency of base names among join params that do not have a custom alias\r\n        Map<String, Long> baseNameCount = new HashMap<>();\r\n        for (ParamInfo pi : joinParamInfos) {\r\n            if (pi.aliasPrefix == null) {\r\n                baseNameCount.put(pi.baseName, baseNameCount.getOrDefault(pi.baseName, 0L) + 1);\r\n            }\r\n        }\r\n        // Determine final DTO field names for each parameter\r\n        List<FieldSpec> fieldSpecs = new ArrayList<>();\r\n        for (VariableElement param : params) {\r\n            String paramName = param.getSimpleName().toString();\r\n            TypeMirror paramType = param.asType();\r\n            String fieldName;\r\n            if (!paramName.contains(\"_\")) {\r\n                // Main field: name stays the same\r\n                fieldName = paramName;\r\n            } else {\r\n                String prefix = paramName.substring(0, paramName.indexOf('_'));\r\n                String baseName = paramName.substring(paramName.indexOf('_') + 1);\r\n                PfxAlias aliasAnn = param.getAnnotation(PfxAlias.class);\r\n                if (aliasAnn != null) {\r\n                    // Use custom prefix\r\n                    String customPrefix = aliasAnn.name();\r\n                    fieldName = customPrefix + capitalize(baseName);\r\n                } else {\r\n                    boolean conflict = mainFieldNames.contains(baseName) || (baseNameCount.getOrDefault(baseName, 0L) > 1);\r\n                    if (conflict) {\r\n                        fieldName = prefix + capitalize(baseName);\r\n                    } else {\r\n                        fieldName = baseName;\r\n                    }\r\n                }\r\n            }\r\n            // Determine the Java type for the field (use simple name for output if possible)\r\n            String fieldType = getTypeString(paramType, packageName);\r\n            fieldSpecs.add(new FieldSpec(fieldName, fieldType, param));\r\n        }\r\n\r\n        // Generate field declarations\r\n        for (FieldSpec fs : fieldSpecs) {\r\n            classContent.append(\"    private \").append(fs.type).append(\" \").append(fs.name).append(\";\\n\");\r\n        }\r\n        classContent.append(\"\\n\");\r\n\r\n        // Generate constructor\r\n        String entityParamName = decapitalize(entitySimpleName);\r\n        classContent.append(\"    public \").append(dtoClassName)\r\n                .append(\"(\").append(entitySimpleName).append(\" \").append(entityParamName).append(\") {\\n\");\r\n        // We will build join chain expressions as we iterate fields in original param order\r\n        int aliasCounter = 1;\r\n        // Maps to keep track of active join aliases and object access paths\r\n        Map<String, String> prefixToAlias = new HashMap<>();\r\n        Map<String, String> prefixToObjectPath = new HashMap<>();\r\n        boolean chainActive = false;\r\n        String currentChainPrefix = null;\r\n        String currentObjectPath = null;\r\n        // We'll also keep track of the last seen join level prefix for continuing deeper joins\r\n        String lastJoinPrefix = null;\r\n        for (VariableElement param : params) {\r\n            String paramName = param.getSimpleName().toString();\r\n            // Find corresponding FieldSpec (to get DTO field name)\r\n            FieldSpec fs = fieldSpecs.stream()\r\n                    .filter(f -> f.paramElement.equals(param))\r\n                    .findFirst().orElse(null);\r\n            if (fs == null) continue;\r\n            String dtoFieldName = fs.name;\r\n            if (!paramName.contains(\"_\")) {\r\n                // Main field mapping: direct from entity\r\n                // End any active chain if present\r\n                chainActive = false;\r\n                prefixToAlias.clear();\r\n                prefixToObjectPath.clear();\r\n                lastJoinPrefix = null;\r\n                // Assign using entity's getter\r\n                String getterName = \"get\" + capitalize(paramName);\r\n                classContent.append(\"        this.\").append(dtoFieldName)\r\n                        .append(\" = \").append(entityParamName).append(\".\")\r\n                        .append(getterName).append(\"();\\n\");\r\n            } else {\r\n                // Joined field mapping\r\n                String prefix = paramName.substring(0, paramName.indexOf('_'));\r\n                String baseName = paramName.substring(paramName.indexOf('_') + 1);\r\n                JoinLevel joinAnn = param.getAnnotation(JoinLevel.class);\r\n                Next nextAnn = param.getAnnotation(Next.class);\r\n                if (joinAnn != null || !chainActive) {\r\n                    // Start a new join chain\r\n                    prefixToAlias.clear();\r\n                    prefixToObjectPath.clear();\r\n                    chainActive = true;\r\n                    lastJoinPrefix = prefix;\r\n                    // Assign a new alias for this join level\r\n                    String alias = \"t\" + aliasCounter++;\r\n                    prefixToAlias.put(prefix, alias);\r\n                    // Build object access path for this association\r\n                    String getterName = \"get\" + capitalize(prefix);\r\n                    currentObjectPath = entityParamName + \".\" + getterName + \"()\";\r\n                    prefixToObjectPath.put(prefix, currentObjectPath);\r\n                    // Map field from the joined object\r\n                    String fieldGetter = \"get\" + capitalize(baseName);\r\n                    classContent.append(\"        this.\").append(dtoFieldName)\r\n                            .append(\" = \").append(currentObjectPath).append(\".\")\r\n                            .append(fieldGetter).append(\"();\\n\");\r\n                } else if (nextAnn != null) {\r\n                    // Continue to next level in the existing chain\r\n                    // Extend the object path from the last prefix\r\n                    String prevObjectPath = currentObjectPath;\r\n                    // Assign a new alias for the next join level\r\n                    String alias = \"t\" + aliasCounter++;\r\n                    prefixToAlias.put(prefix, alias);\r\n                    // Build object access for next association\r\n                    String getterName = \"get\" + capitalize(prefix);\r\n                    currentObjectPath = prevObjectPath + \".\" + getterName + \"()\";\r\n                    lastJoinPrefix = prefix;\r\n                    prefixToObjectPath.put(prefix, currentObjectPath);\r\n                    // Map field from the new joined object\r\n                    String fieldGetter = \"get\" + capitalize(baseName);\r\n                    classContent.append(\"        this.\").append(dtoFieldName)\r\n                            .append(\" = \").append(currentObjectPath).append(\".\")\r\n                            .append(fieldGetter).append(\"();\\n\");\r\n                } else {\r\n                    // Additional field from an already joined object (same level or earlier in chain)\r\n                    if (prefixToObjectPath.containsKey(prefix)) {\r\n                        // Use existing join object path\r\n                        String objectPath = prefixToObjectPath.get(prefix);\r\n                        String fieldGetter = \"get\" + capitalize(baseName);\r\n                        classContent.append(\"        this.\").append(dtoFieldName)\r\n                                .append(\" = \").append(objectPath).append(\".\")\r\n                                .append(fieldGetter).append(\"();\\n\");\r\n                    } else {\r\n                        // This scenario shouldn't normally occur (undefined join prefix without annotation)\r\n                        classContent.append(\"        // Warning: undefined join prefix '\").append(prefix)\r\n                                .append(\"' for field \").append(dtoFieldName).append(\"\\n\");\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        classContent.append(\"    }\\n\\n\");\r\n\r\n        // Generate getter and setter methods for each field\r\n        for (FieldSpec fs : fieldSpecs) {\r\n            String fieldName = fs.name;\r\n            String fieldType = fs.type;\r\n            // Getter\r\n            String capName = capitalize(fieldName);\r\n            classContent.append(\"    public \").append(fieldType).append(\" get\").append(capName)\r\n                    .append(\"() {\\n        return this.\").append(fieldName).append(\";\\n    }\\n\\n\");\r\n            // Setter\r\n            classContent.append(\"    public void set\").append(capName).append(\"(\")\r\n                    .append(fieldType).append(\" \").append(fieldName).append(\") {\\n\")\r\n                    .append(\"        this.\").append(fieldName).append(\" = \").append(fieldName).append(\";\\n    }\\n\\n\");\r\n        }\r\n\r\n        // Static block for DTOFactory and DTOSelectFieldsListFactory registration\r\n        classContent.append(\"    static {\\n\");\r\n        // Register DTO class in DTOFactory\r\n        classContent.append(\"        DTOFactory.register(\").append(entitySimpleName).append(\".class, \\\"\")\r\n                .append(dtoId).append(\"\\\", \").append(dtoClassName).append(\".class);\\n\");\r\n        // Build select field path list\r\n        classContent.append(\"        List<String> __selectFields = new ArrayList<>();\\n\");\r\n        aliasCounter = 1;\r\n        prefixToAlias.clear();\r\n        // We will iterate again through parameters to add field paths (t0, t1, etc.) in order\r\n        boolean chainActiveForPaths = false;\r\n        lastJoinPrefix = null;\r\n        for (VariableElement param : params) {\r\n            String paramName = param.getSimpleName().toString();\r\n            if (!paramName.contains(\"_\")) {\r\n                // main field\r\n                classContent.append(\"        __selectFields.add(\\\"t0.\").append(paramName).append(\"\\\");\\n\");\r\n                chainActiveForPaths = false;\r\n                prefixToAlias.clear();\r\n                lastJoinPrefix = null;\r\n            } else {\r\n                String prefix = paramName.substring(0, paramName.indexOf('_'));\r\n                String baseName = paramName.substring(paramName.indexOf('_') + 1);\r\n                JoinLevel joinAnn = param.getAnnotation(JoinLevel.class);\r\n                Next nextAnn = param.getAnnotation(Next.class);\r\n                if (joinAnn != null || !chainActiveForPaths) {\r\n                    // new chain or chain start\r\n                    String alias = \"t\" + aliasCounter++;\r\n                    prefixToAlias.clear();\r\n                    prefixToAlias.put(prefix, alias);\r\n                    chainActiveForPaths = true;\r\n                    lastJoinPrefix = prefix;\r\n                    classContent.append(\"        __selectFields.add(\\\"\").append(alias).append(\".\").append(baseName).append(\"\\\");\\n\");\r\n                } else if (nextAnn != null) {\r\n                    // next level in existing chain\r\n                    String alias = \"t\" + aliasCounter++;\r\n                    prefixToAlias.put(prefix, alias);\r\n                    lastJoinPrefix = prefix;\r\n                    classContent.append(\"        __selectFields.add(\\\"\").append(alias).append(\".\").append(baseName).append(\"\\\");\\n\");\r\n                } else {\r\n                    // additional field from existing join level (reuse current alias for that prefix)\r\n                    if (prefixToAlias.containsKey(prefix)) {\r\n                        String alias = prefixToAlias.get(prefix);\r\n                        classContent.append(\"        __selectFields.add(\\\"\").append(alias).append(\".\").append(baseName).append(\"\\\");\\n\");\r\n                    } else {\r\n                        // Should not happen normally\r\n                        classContent.append(\"        __selectFields.add(\\\"t?.\").append(baseName).append(\"\\\"); // prefix '\")\r\n                                .append(prefix).append(\"' not found\\n\");\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        classContent.append(\"        DTOSelectFieldsListFactory.register(\")\r\n                .append(entitySimpleName).append(\".class, \\\"\").append(dtoId)\r\n                .append(\"\\\", __selectFields);\\n\");\r\n        classContent.append(\"    }\\n\");\r\n\r\n        // Close class\r\n        classContent.append(\"}\\n\");\r\n\r\n        // Write the generated class to a .java file\r\n        try {\r\n            JavaFileObject fileObject = processingEnv.getFiler()\r\n                    .createSourceFile(packageName.isEmpty() ? dtoClassName : packageName + \".\" + dtoClassName, entityClass);\r\n            try (Writer writer = fileObject.openWriter()) {\r\n                writer.write(classContent.toString());\r\n            }\r\n        } catch (IOException e) {\r\n            // Log error if file creation fails\r\n            processingEnv.getMessager().printMessage(Diagnostic.Kind.ERROR,\r\n                    \"Failed to write DTO class: \" + e.getMessage(), entityClass);\r\n        }\r\n    }\r\n\r\n    /** Helper to capitalize the first letter of a string. */\r\n    private String capitalize(String str) {\r\n        if (str == null || str.isEmpty()) return str;\r\n        // If second letter is uppercase, we still capitalize first (to preserve acronyms properly).\r\n        return str.substring(0, 1).toUpperCase() + str.substring(1);\r\n    }\r\n\r\n    /**\r\n     * Helper to convert a string with possible underscores to camel case.\r\n     * If capitalizeFirst is true, the first letter of the result will be uppercase.\r\n     */\r\n    private String toCamelCase(String input, boolean capitalizeFirst) {\r\n        if (input == null) return null;\r\n        StringBuilder sb = new StringBuilder();\r\n        boolean upperNext = capitalizeFirst;\r\n        for (int i = 0; i < input.length(); i++) {\r\n            char c = input.charAt(i);\r\n            if (c == '_' || c == ' ' || c == '-') {\r\n                upperNext = true;\r\n            } else if (upperNext) {\r\n                sb.append(Character.toUpperCase(c));\r\n                upperNext = false;\r\n            } else {\r\n                sb.append(c);\r\n            }\r\n        }\r\n        return sb.toString();\r\n    }\r\n\r\n    /**\r\n     * Helper to get the type name as a string for field declarations, handling imports.\r\n     */\r\n    private String getTypeString(TypeMirror typeMirror, String currentPackage) {\r\n        // Primitive types:\r\n        if (typeMirror.getKind().isPrimitive()) {\r\n            return typeMirror.toString();  // e.g., \"int\", \"long\"\r\n        }\r\n        // Declared types (classes):\r\n        if (typeMirror instanceof DeclaredType) {\r\n            TypeElement typeElem = (TypeElement) ((DeclaredType) typeMirror).asElement();\r\n            String qualName = processingEnv.getElementUtils().getBinaryName(typeElem).toString();\r\n            String simpleName = typeElem.getSimpleName().toString();\r\n            // Use simple name for java.lang classes or classes in same package\r\n            if (qualName.startsWith(\"java.lang.\")) {\r\n                return simpleName;\r\n            }\r\n            if (!currentPackage.isEmpty() && qualName.startsWith(currentPackage + \".\")) {\r\n                return simpleName;\r\n            }\r\n            // Otherwise, use fully qualified name (or import in class header, but here we output FQCN to be safe)\r\n            return qualName;\r\n        }\r\n        // Other types (arrays, etc.)\r\n        return typeMirror.toString();\r\n    }\r\n\r\n    /** Simple struct to hold join parameter info for naming. */\r\n    private static class ParamInfo {\r\n        String prefix;\r\n        String baseName;\r\n        String aliasPrefix;\r\n        ParamInfo(String prefix, String baseName, String aliasPrefix) {\r\n            this.prefix = prefix;\r\n            this.baseName = baseName;\r\n            this.aliasPrefix = aliasPrefix;\r\n        }\r\n    }\r\n\r\n    /** Simple struct to hold field specifications for generation. */\r\n    private static class FieldSpec {\r\n        String name;\r\n        String type;\r\n        VariableElement paramElement;\r\n        FieldSpec(String name, String type, VariableElement element) {\r\n            this.name = name;\r\n            this.type = type;\r\n            this.paramElement = element;\r\n        }\r\n    }\r\n\r\n    /** Decapitalize the first letter (for entity instance variable naming). */\r\n    private String decapitalize(String str) {\r\n        if (str == null || str.isEmpty()) return str;\r\n        if (str.length() > 1 && Character.isUpperCase(str.charAt(0))\r\n                && Character.isUpperCase(str.charAt(1))) {\r\n            // If first two are uppercase (acronym), leave as is to avoid changing \"URL\" to \"uRL\"\r\n            return str;\r\n        }\r\n        return str.substring(0, 1).toLowerCase() + str.substring(1);\r\n    }\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/com/doth/selector/anno/processor/DTOConstructorProcessor.java b/src/main/java/com/doth/selector/anno/processor/DTOConstructorProcessor.java
--- a/src/main/java/com/doth/selector/anno/processor/DTOConstructorProcessor.java	(revision 87e6f271238a38728638a807e186f42abc0ad1e0)
+++ b/src/main/java/com/doth/selector/anno/processor/DTOConstructorProcessor.java	(date 1748879684634)
@@ -1,6 +1,6 @@
 package com.doth.selector.anno.processor;
 
-import com.doth.selector.anno.*;  // Import the custom annotations
+import com.doth.selector.anno.*;  // 导入自定义注解
 import com.google.auto.service.AutoService;
 
 import javax.annotation.processing.*;
@@ -19,8 +19,6 @@
 @SupportedAnnotationTypes("com.doth.selector.anno.DTOConstructor")
 public class DTOConstructorProcessor extends AbstractProcessor {
 
-
-
     private Filer filer;
     private Messager messager;
     private Types typeUtils;
@@ -31,7 +29,9 @@
         return SourceVersion.latestSupported();
     }
 
-    // 初始化注解处理器上下文环境
+    /**
+     * 初始化注解处理器上下文环境
+     */
     @Override
     public synchronized void init(ProcessingEnvironment env) {
         super.init(env);
@@ -43,7 +43,7 @@
 
     @Override
     public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv) {
-        // Find all constructors annotated with @DTOConstructor
+        // 查找所有被 @DTOConstructor 注解标注的构造方法
         for (Element elem : roundEnv.getElementsAnnotatedWith(DTOConstructor.class)) {
             if (!(elem instanceof ExecutableElement)) {
                 continue;
@@ -58,10 +58,10 @@
     }
 
     /**
-     * Generates the DTO class source file for the given entity and constructor.
+     * 生成给定实体和构造方法的 DTO 类源文件
      */
     private void generateDtoClass(TypeElement entityClass, ExecutableElement constructorElement, String dtoId) {
-        // Determine package name of entity
+        // 确定实体类的包名
         Elements elementUtils = processingEnv.getElementUtils();
         String entityQualifiedName = elementUtils.getBinaryName(entityClass).toString();
         String packageName = "";
@@ -69,76 +69,80 @@
         if (lastDot > 0) {
             packageName = entityQualifiedName.substring(0, lastDot);
         }
-        // Determine DTO class name (capitalize dtoId, handle underscores if any)
-        String dtoClassName = toCamelCase(dtoId, true);  // true for capitalize first letter
-        // Prepare content builder for class
+
+        // 根据 dtoId 确定 DTO 类名（首字母大写，处理下划线）
+        String dtoClassName = toCamelCase(dtoId, true);
+
+        // 准备构建类内容的 StringBuilder
         StringBuilder classContent = new StringBuilder();
         if (!packageName.isEmpty()) {
             classContent.append("package ").append(packageName).append(";\n\n");
         }
-        // Import statements for annotations and any needed classes
+
+        // 导入所需的类
         classContent.append("import java.util.ArrayList;\n");
         classContent.append("import java.util.List;\n");
-        // Import the annotations (if not in same package)
         classContent.append("import com.doth.selector.anno.DependOn;\n");
-        classContent.append("import com.doth.selector.anno.DTOConstructor;\n");  // in case needed for clarity, though not used inside class
-        // Import entity class if not same package
+        classContent.append("import com.doth.selector.anno.DTOConstructor;\n");
+
+        // 如果实体类不在同一包中，导入实体类
         String entitySimpleName = entityClass.getSimpleName().toString();
         if (!packageName.isEmpty() && !entityQualifiedName.equals(packageName + "." + entitySimpleName)) {
-            // If the entity class is in a different package (which would be unusual if names differ),
-            // but typically entityQualifiedName = packageName + "." + entitySimpleName.
-            // We'll ensure import is correct:
             classContent.append("import ").append(entityQualifiedName).append(";\n");
         }
-        // Import DTOFactory and DTOSelectFieldsListFactory (assuming they are in accessible packages)
+
+        // 导入 DTOFactory 和 DTOSelectFieldsListFactory（假设它们在可访问的包中）
         classContent.append("import com.doth.selector.dto.DTOFactory;\n");
-        classContent.append("import com.doth.selector.dto.DTOSelectFieldsListFactory;\n\n");  // Adjust package as appropriate
+        classContent.append("import com.doth.selector.dto.DTOSelectFieldsListFactory;\n\n");
 
-        // Class definition with @DependOn
+        // 类定义，带 @DependOn 注解
         classContent.append("@DependOn(clzPath=\"").append(entityQualifiedName).append("\")\n");
         classContent.append("public class ").append(dtoClassName).append(" {\n\n");
 
-        // Fields: one for each constructor parameter
+        // 收集构造方法参数信息
         List<? extends VariableElement> params = constructorElement.getParameters();
-        // Determine naming for each field
-        Set<String> mainFieldNames = new HashSet<>();       // names of main entity fields
-        List<ParamInfo> joinParamInfos = new ArrayList<>(); // info for join parameters
+
+        // 用于存储主表字段名
+        Set<String> mainFieldNames = new HashSet<>();
+        // 用于存储关联参数信息（前缀、字段基名、自定义别名）
+        List<ParamInfo> joinParamInfos = new ArrayList<>();
         for (VariableElement param : params) {
             String paramName = param.getSimpleName().toString();
             if (!paramName.contains("_")) {
                 mainFieldNames.add(paramName);
             } else {
-                // Collect join param info (prefix and base name)
                 String prefix = paramName.substring(0, paramName.indexOf('_'));
                 String baseName = paramName.substring(paramName.indexOf('_') + 1);
-                // Check for @PfxAlias on this parameter
+                // 检查 @PfxAlias 注解
                 PfxAlias aliasAnn = param.getAnnotation(PfxAlias.class);
                 String aliasPrefix = (aliasAnn != null ? aliasAnn.name() : null);
                 joinParamInfos.add(new ParamInfo(prefix, baseName, aliasPrefix));
             }
         }
-        // Compute frequency of base names among join params that do not have a custom alias
+
+        // 统计不带自定义别名前缀的关联字段基名出现频率
         Map<String, Long> baseNameCount = new HashMap<>();
         for (ParamInfo pi : joinParamInfos) {
             if (pi.aliasPrefix == null) {
                 baseNameCount.put(pi.baseName, baseNameCount.getOrDefault(pi.baseName, 0L) + 1);
             }
         }
-        // Determine final DTO field names for each parameter
+
+        // 根据参数信息生成最终 DTO 字段规格
         List<FieldSpec> fieldSpecs = new ArrayList<>();
         for (VariableElement param : params) {
             String paramName = param.getSimpleName().toString();
             TypeMirror paramType = param.asType();
             String fieldName;
             if (!paramName.contains("_")) {
-                // Main field: name stays the same
+                // 主表字段：名称不变
                 fieldName = paramName;
             } else {
                 String prefix = paramName.substring(0, paramName.indexOf('_'));
                 String baseName = paramName.substring(paramName.indexOf('_') + 1);
                 PfxAlias aliasAnn = param.getAnnotation(PfxAlias.class);
                 if (aliasAnn != null) {
-                    // Use custom prefix
+                    // 使用自定义前缀
                     String customPrefix = aliasAnn.name();
                     fieldName = customPrefix + capitalize(baseName);
                 } else {
@@ -150,152 +154,163 @@
                     }
                 }
             }
-            // Determine the Java type for the field (use simple name for output if possible)
+            // 确定字段类型（如果在同一包或 java.lang 中，可使用简单名，否则使用全限定名）
             String fieldType = getTypeString(paramType, packageName);
             fieldSpecs.add(new FieldSpec(fieldName, fieldType, param));
         }
 
-        // Generate field declarations
+        // 生成字段声明
         for (FieldSpec fs : fieldSpecs) {
             classContent.append("    private ").append(fs.type).append(" ").append(fs.name).append(";\n");
         }
         classContent.append("\n");
 
-        // Generate constructor
+        // 生成无参构造方法
+        classContent.append("    public ").append(dtoClassName).append("() {}\n\n");
+
+        // 生成接收实体对象的构造方法
         String entityParamName = decapitalize(entitySimpleName);
         classContent.append("    public ").append(dtoClassName)
-                .append("(").append(entitySimpleName).append(" ").append(entityParamName).append(") {\n");
-        // We will build join chain expressions as we iterate fields in original param order
+                    .append("(").append(entitySimpleName).append(" ").append(entityParamName).append(") {\n");
+
         int aliasCounter = 1;
-        // Maps to keep track of active join aliases and object access paths
+        // 存储每个前缀对应的别名及对象访问路径
         Map<String, String> prefixToAlias = new HashMap<>();
         Map<String, String> prefixToObjectPath = new HashMap<>();
         boolean chainActive = false;
-        String currentChainPrefix = null;
         String currentObjectPath = null;
-        // We'll also keep track of the last seen join level prefix for continuing deeper joins
         String lastJoinPrefix = null;
+
         for (VariableElement param : params) {
             String paramName = param.getSimpleName().toString();
-            // Find corresponding FieldSpec (to get DTO field name)
             FieldSpec fs = fieldSpecs.stream()
                     .filter(f -> f.paramElement.equals(param))
-                    .findFirst().orElse(null);
+                    .findFirst()
+                    .orElse(null);
             if (fs == null) continue;
             String dtoFieldName = fs.name;
+
             if (!paramName.contains("_")) {
-                // Main field mapping: direct from entity
-                // End any active chain if present
+                // 主表字段映射：直接通过实体 getter 赋值
                 chainActive = false;
                 prefixToAlias.clear();
                 prefixToObjectPath.clear();
                 lastJoinPrefix = null;
-                // Assign using entity's getter
+
                 String getterName = "get" + capitalize(paramName);
                 classContent.append("        this.").append(dtoFieldName)
                         .append(" = ").append(entityParamName).append(".")
                         .append(getterName).append("();\n");
             } else {
-                // Joined field mapping
+                // 关联字段映射
                 String prefix = paramName.substring(0, paramName.indexOf('_'));
                 String baseName = paramName.substring(paramName.indexOf('_') + 1);
                 JoinLevel joinAnn = param.getAnnotation(JoinLevel.class);
                 Next nextAnn = param.getAnnotation(Next.class);
+
                 if (joinAnn != null || !chainActive) {
-                    // Start a new join chain
+                    // 新的关联链开始
                     prefixToAlias.clear();
                     prefixToObjectPath.clear();
                     chainActive = true;
                     lastJoinPrefix = prefix;
-                    // Assign a new alias for this join level
+
+                    // 分配新的别名
                     String alias = "t" + aliasCounter++;
                     prefixToAlias.put(prefix, alias);
-                    // Build object access path for this association
+
+                    // 构建访问路径：entity.getPrefix()
                     String getterName = "get" + capitalize(prefix);
                     currentObjectPath = entityParamName + "." + getterName + "()";
                     prefixToObjectPath.put(prefix, currentObjectPath);
-                    // Map field from the joined object
+
+                    // 从关联对象获取字段值
                     String fieldGetter = "get" + capitalize(baseName);
                     classContent.append("        this.").append(dtoFieldName)
                             .append(" = ").append(currentObjectPath).append(".")
                             .append(fieldGetter).append("();\n");
                 } else if (nextAnn != null) {
-                    // Continue to next level in the existing chain
-                    // Extend the object path from the last prefix
+                    // 当前关联链的下一层
                     String prevObjectPath = currentObjectPath;
-                    // Assign a new alias for the next join level
+
                     String alias = "t" + aliasCounter++;
                     prefixToAlias.put(prefix, alias);
-                    // Build object access for next association
+
                     String getterName = "get" + capitalize(prefix);
                     currentObjectPath = prevObjectPath + "." + getterName + "()";
                     lastJoinPrefix = prefix;
                     prefixToObjectPath.put(prefix, currentObjectPath);
-                    // Map field from the new joined object
+
                     String fieldGetter = "get" + capitalize(baseName);
                     classContent.append("        this.").append(dtoFieldName)
                             .append(" = ").append(currentObjectPath).append(".")
                             .append(fieldGetter).append("();\n");
                 } else {
-                    // Additional field from an already joined object (same level or earlier in chain)
+                    // 已存在的同层级关联字段（不带注解的参数）
                     if (prefixToObjectPath.containsKey(prefix)) {
-                        // Use existing join object path
                         String objectPath = prefixToObjectPath.get(prefix);
                         String fieldGetter = "get" + capitalize(baseName);
                         classContent.append("        this.").append(dtoFieldName)
                                 .append(" = ").append(objectPath).append(".")
                                 .append(fieldGetter).append("();\n");
                     } else {
-                        // This scenario shouldn't normally occur (undefined join prefix without annotation)
-                        classContent.append("        // Warning: undefined join prefix '").append(prefix)
-                                .append("' for field ").append(dtoFieldName).append("\n");
+                        // 正常情况下不会出现此情况（未定义的关联前缀）
+                        classContent.append("        // 警告：未定义的关联前缀 '")
+                                .append(prefix).append("' 对应字段 ").append(dtoFieldName).append("\n");
                     }
                 }
             }
         }
         classContent.append("    }\n\n");
 
-        // Generate getter and setter methods for each field
+        // 生成每个字段的 getter 和 setter 方法
         for (FieldSpec fs : fieldSpecs) {
             String fieldName = fs.name;
             String fieldType = fs.type;
-            // Getter
             String capName = capitalize(fieldName);
-            classContent.append("    public ").append(fieldType).append(" get").append(capName)
-                    .append("() {\n        return this.").append(fieldName).append(";\n    }\n\n");
+
+            // Getter
+            classContent.append("    public ").append(fieldType).append(" get").append(capName).append("() {\n")
+                        .append("        return this.").append(fieldName).append(";\n")
+                        .append("    }\n\n");
+
             // Setter
             classContent.append("    public void set").append(capName).append("(")
-                    .append(fieldType).append(" ").append(fieldName).append(") {\n")
-                    .append("        this.").append(fieldName).append(" = ").append(fieldName).append(";\n    }\n\n");
+                        .append(fieldType).append(" ").append(fieldName).append(") {\n")
+                        .append("        this.").append(fieldName).append(" = ").append(fieldName).append(";\n")
+                        .append("    }\n\n");
         }
 
-        // Static block for DTOFactory and DTOSelectFieldsListFactory registration
+        // 静态代码块：将 DTO 类注册到工厂，并注册查询字段列表
         classContent.append("    static {\n");
-        // Register DTO class in DTOFactory
-        classContent.append("        DTOFactory.register(").append(entitySimpleName).append(".class, \"")
-                .append(dtoId).append("\", ").append(dtoClassName).append(".class);\n");
-        // Build select field path list
+        // 在 DTOFactory 中注册 DTO 类
+        classContent.append("        DTOFactory.register(").append(entitySimpleName)
+                .append(".class, \"").append(dtoId).append("\", ").append(dtoClassName).append(".class);\n");
+
+        // 构建查询字段路径列表
         classContent.append("        List<String> __selectFields = new ArrayList<>();\n");
         aliasCounter = 1;
         prefixToAlias.clear();
-        // We will iterate again through parameters to add field paths (t0, t1, etc.) in order
         boolean chainActiveForPaths = false;
         lastJoinPrefix = null;
+
         for (VariableElement param : params) {
             String paramName = param.getSimpleName().toString();
             if (!paramName.contains("_")) {
-                // main field
+                // 主表字段
                 classContent.append("        __selectFields.add(\"t0.").append(paramName).append("\");\n");
                 chainActiveForPaths = false;
                 prefixToAlias.clear();
                 lastJoinPrefix = null;
             } else {
+                // 关联字段
                 String prefix = paramName.substring(0, paramName.indexOf('_'));
                 String baseName = paramName.substring(paramName.indexOf('_') + 1);
                 JoinLevel joinAnn = param.getAnnotation(JoinLevel.class);
                 Next nextAnn = param.getAnnotation(Next.class);
+
                 if (joinAnn != null || !chainActiveForPaths) {
-                    // new chain or chain start
+                    // 开始新的关联链
                     String alias = "t" + aliasCounter++;
                     prefixToAlias.clear();
                     prefixToAlias.put(prefix, alias);
@@ -303,33 +318,35 @@
                     lastJoinPrefix = prefix;
                     classContent.append("        __selectFields.add(\"").append(alias).append(".").append(baseName).append("\");\n");
                 } else if (nextAnn != null) {
-                    // next level in existing chain
+                    // 继续当前关联链下一层
                     String alias = "t" + aliasCounter++;
                     prefixToAlias.put(prefix, alias);
                     lastJoinPrefix = prefix;
                     classContent.append("        __selectFields.add(\"").append(alias).append(".").append(baseName).append("\");\n");
                 } else {
-                    // additional field from existing join level (reuse current alias for that prefix)
+                    // 同层级重复字段（不带注解）
                     if (prefixToAlias.containsKey(prefix)) {
                         String alias = prefixToAlias.get(prefix);
                         classContent.append("        __selectFields.add(\"").append(alias).append(".").append(baseName).append("\");\n");
                     } else {
-                        // Should not happen normally
-                        classContent.append("        __selectFields.add(\"t?.").append(baseName).append("\"); // prefix '")
-                                .append(prefix).append("' not found\n");
+                        // 正常情况下不应出现此情况
+                        classContent.append("        __selectFields.add(\"t?.").append(baseName)
+                                .append("\"); // 未找到前缀 '").append(prefix).append("'\n");
                     }
                 }
             }
         }
+
+        // 在 DTOSelectFieldsListFactory 中注册查询字段列表
         classContent.append("        DTOSelectFieldsListFactory.register(")
                 .append(entitySimpleName).append(".class, \"").append(dtoId)
                 .append("\", __selectFields);\n");
         classContent.append("    }\n");
 
-        // Close class
+        // 结束类定义
         classContent.append("}\n");
 
-        // Write the generated class to a .java file
+        // 将生成的类写入 .java 文件
         try {
             JavaFileObject fileObject = processingEnv.getFiler()
                     .createSourceFile(packageName.isEmpty() ? dtoClassName : packageName + "." + dtoClassName, entityClass);
@@ -337,22 +354,23 @@
                 writer.write(classContent.toString());
             }
         } catch (IOException e) {
-            // Log error if file creation fails
+            // 如果写文件失败，打印错误信息
             processingEnv.getMessager().printMessage(Diagnostic.Kind.ERROR,
-                    "Failed to write DTO class: " + e.getMessage(), entityClass);
+                    "无法写入 DTO 类: " + e.getMessage(), entityClass);
         }
     }
 
-    /** Helper to capitalize the first letter of a string. */
+    /**
+     * 将字符串首字母大写，例如 "name" -> "Name"
+     */
     private String capitalize(String str) {
         if (str == null || str.isEmpty()) return str;
-        // If second letter is uppercase, we still capitalize first (to preserve acronyms properly).
         return str.substring(0, 1).toUpperCase() + str.substring(1);
     }
 
     /**
-     * Helper to convert a string with possible underscores to camel case.
-     * If capitalizeFirst is true, the first letter of the result will be uppercase.
+     * 将可能包含下划线的字符串转换为驼峰形式。
+     * 如果 capitalizeFirst 为 true，则首字母大写。
      */
     private String toCamelCase(String input, boolean capitalizeFirst) {
         if (input == null) return null;
@@ -373,37 +391,42 @@
     }
 
     /**
-     * Helper to get the type name as a string for field declarations, handling imports.
+     * 获取字段声明时的类型名称，处理导入逻辑：
+     * - 原始类型直接返回类型名
+     * - 如果是 java.lang 下的类型或当前包下的类型，使用简单类名
+     * - 否则使用全限定名
      */
     private String getTypeString(TypeMirror typeMirror, String currentPackage) {
-        // Primitive types:
         if (typeMirror.getKind().isPrimitive()) {
-            return typeMirror.toString();  // e.g., "int", "long"
+            return typeMirror.toString();
         }
-        // Declared types (classes):
         if (typeMirror instanceof DeclaredType) {
             TypeElement typeElem = (TypeElement) ((DeclaredType) typeMirror).asElement();
             String qualName = processingEnv.getElementUtils().getBinaryName(typeElem).toString();
             String simpleName = typeElem.getSimpleName().toString();
-            // Use simple name for java.lang classes or classes in same package
+            // java.lang 下的类型使用简单名
             if (qualName.startsWith("java.lang.")) {
                 return simpleName;
             }
+            // 当前包下的类型使用简单名
             if (!currentPackage.isEmpty() && qualName.startsWith(currentPackage + ".")) {
                 return simpleName;
             }
-            // Otherwise, use fully qualified name (or import in class header, but here we output FQCN to be safe)
+            // 否则使用全限定名
             return qualName;
         }
-        // Other types (arrays, etc.)
+        // 其他类型（数组等）直接返回 toString()
         return typeMirror.toString();
     }
 
-    /** Simple struct to hold join parameter info for naming. */
+    /**
+     * 存储关联参数信息（前缀、字段基名以及自定义别名前缀）
+     */
     private static class ParamInfo {
         String prefix;
         String baseName;
         String aliasPrefix;
+
         ParamInfo(String prefix, String baseName, String aliasPrefix) {
             this.prefix = prefix;
             this.baseName = baseName;
@@ -411,11 +434,14 @@
         }
     }
 
-    /** Simple struct to hold field specifications for generation. */
+    /**
+     * 存储生成字段的规格信息（字段名、类型以及原始参数元素）
+     */
     private static class FieldSpec {
         String name;
         String type;
         VariableElement paramElement;
+
         FieldSpec(String name, String type, VariableElement element) {
             this.name = name;
             this.type = type;
@@ -423,12 +449,14 @@
         }
     }
 
-    /** Decapitalize the first letter (for entity instance variable naming). */
+    /**
+     * 将字符串首字母小写（用于实体实例变量命名），
+     * 如果前两个字母均为大写（如 URL），则不做修改
+     */
     private String decapitalize(String str) {
         if (str == null || str.isEmpty()) return str;
         if (str.length() > 1 && Character.isUpperCase(str.charAt(0))
                 && Character.isUpperCase(str.charAt(1))) {
-            // If first two are uppercase (acronym), leave as is to avoid changing "URL" to "uRL"
             return str;
         }
         return str.substring(0, 1).toLowerCase() + str.substring(1);
Index: src/main/java/com/doth/selector/anno/MainLevel.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/com/doth/selector/anno/MainLevel.java b/src/main/java/com/doth/selector/anno/MainLevel.java
new file mode 100644
--- /dev/null	(date 1748791888562)
+++ b/src/main/java/com/doth/selector/anno/MainLevel.java	(date 1748791888562)
@@ -0,0 +1,10 @@
+package com.doth.selector.anno;
+
+/**
+ * @author 贤
+ * @version 1.0
+ * @date 2025/6/1 23:31
+ * @description
+ */
+public @interface MainLevel {
+}
Index: src/main/java/com/doth/selector/dto/DTOFactory.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.doth.selector.dto;\r\n\r\nimport java.util.*;\r\n\r\npublic class DTOFactory {\r\n    private static final Map<Class<?>, Map<String, Class<?>>> REGISTRY = new HashMap<>();\r\n\r\n    public static void register(Class<?> entityClass, String id, Class<?> dtoClass) {\r\n        REGISTRY.computeIfAbsent(entityClass, k -> new HashMap<>()).put(id, dtoClass);\r\n    }\r\n\r\n    /**\r\n     * 注册dto并获取\r\n     * @param entityClass 原类\r\n     * @param id id\r\n     * @return dto\r\n     */\r\n    public static Class<?> resolve(Class<?> entityClass, String id) {\r\n        if (id == null || id.isBlank()) return entityClass;\r\n\r\n        Map<String, Class<?>> idMap = REGISTRY.get(entityClass);\r\n        if (idMap == null || !idMap.containsKey(id)) {\r\n            // 强制尝试加载 class 并触发 static 注册\r\n            try {\r\n                String fullName = entityClass.getName() + \"$\" + id + \"DTO\";\r\n                ClassLoader cl = entityClass.getClassLoader(); // 确保使用实体类相同的加载器\r\n                Class.forName(fullName, true, cl);\r\n                // Class<?> generatedDTO = Class.forName(fullName, true, cl);\r\n\r\n                // // 如果加载后还是没注册，就说明生成类未触发静态块\r\n                // idMap = REGISTRY.get(entityClass);\r\n                // if (idMap == null || !idMap.containsKey(id)) {\r\n                //     throw new IllegalStateException(\"DTO类加载成功但未注册，请确认 static 注册代码是否写入: \" + fullName);\r\n                // }\r\n                // System.out.println(\"generatedDTO = \" + generatedDTO);\r\n                // return generatedDTO;\r\n\r\n            } catch (ClassNotFoundException e) {\r\n                throw new RuntimeException(\"DTO类未找到: \" + entityClass.getName() + \" id=\" + id, e);\r\n            }\r\n        }\r\n\r\n        return REGISTRY.getOrDefault(entityClass, Collections.emptyMap()).getOrDefault(id, entityClass); // 退回实体类型\r\n    }\r\n\r\n\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/com/doth/selector/dto/DTOFactory.java b/src/main/java/com/doth/selector/dto/DTOFactory.java
--- a/src/main/java/com/doth/selector/dto/DTOFactory.java	(revision 87e6f271238a38728638a807e186f42abc0ad1e0)
+++ b/src/main/java/com/doth/selector/dto/DTOFactory.java	(date 1748863439716)
@@ -3,6 +3,7 @@
 import java.util.*;
 
 public class DTOFactory {
+
     private static final Map<Class<?>, Map<String, Class<?>>> REGISTRY = new HashMap<>();
 
     public static void register(Class<?> entityClass, String id, Class<?> dtoClass) {
@@ -22,7 +23,8 @@
         if (idMap == null || !idMap.containsKey(id)) {
             // 强制尝试加载 class 并触发 static 注册
             try {
-                String fullName = entityClass.getName() + "$" + id + "DTO";
+                // String fullName = entityClass.getName() + "$" + id + "DTO";
+                String fullName = entityClass.getName();
                 ClassLoader cl = entityClass.getClassLoader(); // 确保使用实体类相同的加载器
                 Class.forName(fullName, true, cl);
                 // Class<?> generatedDTO = Class.forName(fullName, true, cl);
